"""
Vulnerability Scanner Service

Сервис для сканирования уязвимостей в коде.
"""

import re
from typing import List

from src.modules.security.domain.exceptions import VulnerabilityScanError
from src.modules.security.domain.models import (
    Severity,
    Vulnerability,
    VulnerabilityScanResult,
    VulnerabilityType,
)
from src.utils.structured_logging import StructuredLogger
from src.infrastructure.event_bus import EventBus, Event, EventType, get_event_bus

logger = StructuredLogger(__name__).logger


class VulnerabilityScanner:
    """
    Сервис сканирования уязвимостей

    Features:
    - SQL injection detection
    - XSS detection
    - CSRF detection
    - Path traversal detection
    - Risk score calculation
    """

    def __init__(self, patterns_repository=None, event_bus: EventBus = None):
        """
        Args:
            patterns_repository: Repository для паттернов уязвимостей
            event_bus: Шина событий для публикации находок
        """
        if patterns_repository is None:
            from src.modules.security.repositories import SecurityPatternsRepository
            patterns_repository = SecurityPatternsRepository()

        self.patterns_repository = patterns_repository
        self.event_bus = event_bus or get_event_bus()
        
        self.vulnerability_patterns = (
            self.patterns_repository.get_vulnerability_patterns()
        )
        
        # Initialize AST Scanner
        from src.modules.security.services.ast_scanner import ASTVulnerabilityScanner
        self.ast_scanner = ASTVulnerabilityScanner()

    async def scan_vulnerabilities(
        self,
        code: str,
        language: str = "python"
    ) -> VulnerabilityScanResult:
        """
        Сканирование кода на уязвимости

        Args:
            code: Код для сканирования
            language: Язык программирования

        Returns:
            VulnerabilityScanResult
        """
        try:
            logger.info(
                "Scanning code for vulnerabilities",
                extra={"language": language}
            )

            vulnerabilities = []

            # SQL Injection detection
            vulnerabilities.extend(
                self._detect_sql_injection(code)
            )

            # XSS detection
            vulnerabilities.extend(
                self._detect_xss(code)
            )

            # Path Traversal detection
            vulnerabilities.extend(
                self._detect_path_traversal(code)
            )

            # Command Injection detection
            vulnerabilities.extend(
                self._detect_command_injection(code)
            )
            
            # AST-based detection (Deep Scan)
            if language == "python":
                ast_vulnerabilities = self.ast_scanner.scan(code)
                vulnerabilities.extend(ast_vulnerabilities)

            # Calculate risk score
            risk_score = self._calculate_risk_score(vulnerabilities)

            # Severity breakdown
            severity_breakdown = self._get_severity_breakdown(
                vulnerabilities
            )
            
            # Publish events for found vulnerabilities
            if self.event_bus:
                for vuln in vulnerabilities:
                    event = Event(
                        type=EventType.VULNERABILITY_FOUND,
                        payload=vuln.dict(),
                        source="security_officer"
                    )
                    await self.event_bus.publish(event)

            return VulnerabilityScanResult(
                vulnerabilities=vulnerabilities,
                risk_score=risk_score,
                severity_breakdown=severity_breakdown
            )

        except Exception as e:
            logger.error("Failed to scan vulnerabilities: %s", e)
            raise VulnerabilityScanError(
                f"Failed to scan vulnerabilities: {e}",
                details={"language": language}
            )

    def _detect_sql_injection(self, code: str) -> List[Vulnerability]:
        """Детекция SQL injection"""
        vulnerabilities = []

        # Pattern: string concatenation in SQL queries
        pattern = r'(execute|query|sql)\s*\(\s*["\'].*?\+.*?["\']'
        matches = re.finditer(pattern, code, re.IGNORECASE)

        for match in matches:
            vulnerabilities.append(
                Vulnerability(
                    type=VulnerabilityType.SQL_INJECTION,
                    severity=Severity.CRITICAL,
                    location="code",
                    line_number=None,
                    description="Potential SQL injection via string concatenation",
                    recommendation="Use parameterized queries or ORM",
                    cwe_id="CWE-89"
                )
            )

        return vulnerabilities

    def _detect_xss(self, code: str) -> List[Vulnerability]:
        """Детекция XSS"""
        vulnerabilities = []

        # Pattern: unescaped user input in HTML
        pattern = r'(innerHTML|outerHTML)\s*=\s*.*?(request|input|params)'
        matches = re.finditer(pattern, code, re.IGNORECASE)

        for match in matches:
            vulnerabilities.append(
                Vulnerability(
                    type=VulnerabilityType.XSS,
                    severity=Severity.HIGH,
                    location="code",
                    line_number=None,
                    description="Potential XSS via unescaped user input",
                    recommendation="Escape user input before rendering",
                    cwe_id="CWE-79"
                )
            )

        return vulnerabilities

    def _detect_path_traversal(self, code: str) -> List[Vulnerability]:
        """Детекция Path Traversal"""
        vulnerabilities = []

        # Pattern: file operations with user input
        pattern = r'(open|read|write)\s*\(.*?(request|input|params)'
        matches = re.finditer(pattern, code, re.IGNORECASE)

        for match in matches:
            vulnerabilities.append(
                Vulnerability(
                    type=VulnerabilityType.PATH_TRAVERSAL,
                    severity=Severity.HIGH,
                    location="code",
                    line_number=None,
                    description="Potential path traversal vulnerability",
                    recommendation="Validate and sanitize file paths",
                    cwe_id="CWE-22"
                )
            )

        return vulnerabilities

    def _detect_command_injection(self, code: str) -> List[Vulnerability]:
        """Детекция Command Injection"""
        vulnerabilities = []

        # Pattern: shell execution with user input
        pattern = r'(exec|system|popen|subprocess)\s*\(.*?(request|input|params)'
        matches = re.finditer(pattern, code, re.IGNORECASE)

        for match in matches:
            vulnerabilities.append(
                Vulnerability(
                    type=VulnerabilityType.COMMAND_INJECTION,
                    severity=Severity.CRITICAL,
                    location="code",
                    line_number=None,
                    description="Potential command injection vulnerability",
                    recommendation="Avoid shell execution with user input",
                    cwe_id="CWE-78"
                )
            )

        return vulnerabilities

    def _calculate_risk_score(
        self,
        vulnerabilities: List[Vulnerability]
    ) -> float:
        """Расчет risk score (0-100)"""
        if not vulnerabilities:
            return 0.0

        severity_weights = {
            "critical": 25,
            "high": 15,
            "medium": 8,
            "low": 3
        }

        total_score = sum(
            severity_weights.get(v.severity.value, 0)
            for v in vulnerabilities
        )

        return min(100.0, round(total_score, 1))

    def _get_severity_breakdown(
        self,
        vulnerabilities: List[Vulnerability]
    ) -> dict:
        """Распределение по серьезности"""
        breakdown = {
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0
        }

        for vuln in vulnerabilities:
            breakdown[vuln.severity.value] += 1

        return breakdown


__all__ = ["VulnerabilityScanner"]
