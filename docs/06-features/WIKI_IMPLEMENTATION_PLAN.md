# Implementation Plan: Wiki 2.0 (Google Code Wiki Standard)

Этот документ описывает детальный план трансформации текущего модуля Wiki в интеллектуальную систему "Живой Документации", ориентированную на стандарты Google Code Wiki.

## 1. Архитектурное видение

Мы переходим от модели "Хранилище статей" к модели "Интеллектуальный слой поверх кода".
Система будет состоять из трех основных компонентов:
1.  **Wiki Core (Существующий Backend)**: Хранение, версии, комментарии.
2.  **Code Intelligence Service (Новый)**: Анализ репозитория, генерация диаграмм, линковка символов.
3.  **Knowledge Portal (Новый Frontend)**: Единый интерфейс для чтения доков и исследования кода.

---

## 2. Этапы реализации (Phases)

### Фаза 1: Фундамент Frontend (Knowledge Portal)
*Цель: Дать пользователю современный интерфейс для работы с тем, что уже есть (ручная документация).*

1.  **Инициализация Frontend-проекта**:
    *   Стек: React, TypeScript, Vite, Tailwind CSS.
    *   Архитектура: Feature-sliced Design (FSD).
2.  **Компоненты просмотра (Viewer)**:
    *   `WikiPageLayout`: Сайдбар с деревом страниц (Namespaces), хлебные крошки.
    *   `MarkdownRenderer`: Рендеринг MD с подсветкой синтаксиса кода (Shiki/Prism).
    *   `VersionSelector`: Выпадающий список для просмотра истории изменений.
3.  **Компоненты редактирования (Editor)**:
    *   Визуальный редактор (WYSIWYG) или Split-view (Code + Preview).
    *   Обработка конфликтов (Optimistic Locking UI).
4.  **Интеграция комментариев**:
    *   Сайдбар обсуждений справа от контента.

**Результат Фазы 1:** Полноценная Wiki-система, которой можно пользоваться.

### Фаза 2: Code Intelligence (Мозг системы)
*Цель: Связать документацию с кодом и обеспечить авто-обновление.*

1.  **Сервис синхронизации (CodeSync Worker)**:
    *   Разработка фонового воркера (Celery/FastStream).
    *   Интеграция с Git: Реакция на Webhook Push или периодический поллинг.
    *   Парсинг файловой структуры: Авто-создание страниц для папок и модулей (Shadow Pages).
2.  **Индексатор символов (Symbol Indexer)**:
    *   Использование `tree-sitter` (или AST парсеров) для извлечения классов, методов, функций.
    *   Сохранение карты символов: `Symbol -> File:Line`.
3.  **Smart Links Middleware**:
    *   Внедрение синтаксиса `[[code:MyClass]]`.
    *   При рендеринге страницы замена таких ссылок на интерактивные popover-ы с превью кода.

**Результат Фазы 2:** Документация "знает" о коде. Ссылки работают, структура проекта отражается в Wiki.

### Фаза 3: Визуализация и Авто-генерация
*Цель: Снизить рутину по рисованию схем и написанию описаний.*

1.  **Auto-Diagrams**:
    *   Интеграция генератора Mermaid/PlantUML.
    *   Автоматическая генерация Class Diagram для каждого модуля на лету.
2.  **AI-Description (LLM Worker)**:
    *   Job для поиска "пустых" авто-созданных страниц.
    *   Промпт к LLM (через Orchestrator): "Проанализируй код файла X и напиши документацию в формате Markdown".
    *   Авто-коммит сгенерированного описания с пометкой "Generated by AI".

### Фаза 4: AI Search & Chat (RAG)
*Цель: Отвечать на сложные вопросы по проекту.*

1.  **Векторизация (Qdrant)**:
    *   Пайплайн: При сохранении страницы или коммите кода -> Эмбеддинг -> Qdrant.
2.  **Чат-интерфейс**:
    *   Виджет "Ask Wiki" на каждой странице.
    *   Контекстный поиск: Ответ учитывает содержимое текущей открытой страницы + связанный код.

---

## 3. Технический Стек и Инструменты

| Компонент | Технология | Зачем |
| :--- | :--- | :--- |
| **Frontend** | **React + Tailwind** | Стандарт индустрии, скорость, гибкость. |
| **Editor** | **Monaco Editor / MDX** | Удобное редактирование кода и текста. |
| **Diagrams** | **Mermaid.js** | Рендеринг диаграмм на клиенте (быстро, без картинок). |
| **Backend** | **FastAPI (Python)** | Уже используется, отлично для AI и асинхронности. |
| **Parsing** | **Tree-sitter** | Быстрый, надежный парсинг любого языка программирования. |
| **Search** | **Qdrant** | Векторный поиск для RAG (уже есть в плане архитектуры). |
| **Task Queue** | **Celery / Redis** | Для тяжелых задач (парсинг репо, генерация AI). |

---

## 4. Оценка ресурсов и сроков (Примерная)

*   **Фаза 1 (Frontend Core):** 2 недели. (Критично для старта)
*   **Фаза 2 (Code Sync):** 2 недели.
*   **Фаза 3 (Auto-Gen):** 1.5 недели.
*   **Фаза 4 (AI RAG):** 1 неделя.

**Итого:** ~1.5 месяца до полной реализации Vision. MVP (Фаза 1) доступен через 2 недели.

---

## 5. Метрики успеха (KPI)

1.  **Coverage**: % файлов проекта, имеющих ассоциированную страницу в Wiki (Цель: 100% за счет авто-генерации).
2.  **Freshness**: Среднее время между изменением кода и обновлением доки (Цель: < 5 минут).
3.  **Engagement**: Количество переходов по Smart Links (показывает полезность связей).

