// [NEXUS IDENTITY] ID: -3222393583894043044 | DATE: 2025-11-19

﻿// Модуль: М1сAIОбщие
// Назначение: Библиотека модулей 1С AI Stack.
//
////////////////////////////////////////////////////////////////////////////////


#Область PublicAPI

// =================================================================
// ПРОВЕРКИ СУЩЕСТВОВАНИЯ И ПУСТОТЫ
// =================================================================

#Region М1сAIОбщие_NotEmpty
/// <summary>
/// Проверяет, что значение не пустое (не Неопределено, не ПустаяСсылка, не пустая строка).
/// </summary>
/// <param name="Значение" type="Arbitrary">Проверяемое значение.</param>
/// <returns type="Boolean">Истина если значение не пустое.</returns>
Функция NotEmpty(Значение) Экспорт
	Если Значение = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ТипЗнч(Значение) = Тип("Строка") Тогда
		Возврат НЕ ПустаяСтрока(Значение);
	КонецЕсли;
	
	Если ТипЗнч(Значение) = Тип("Булево") Тогда
		Возврат True;
	КонецЕсли;

	Попытка
		// Для ссылок проверяем через Пустая()
		Возврат НЕ Значение.Пустая();
	Исключение
		// Для остальных типов - просто проверяем на Неопределено
		Возврат Истина;
	КонецПопытки;
КонецФункции
#Region examples_М1сAIОбщие_NotEmpty
// Примеры:
// М1сAIОбщие.NotEmpty(ПараметрыСеанса.ТекущийПользователь) // Истина если пользователь задан
// М1сAIОбщие.NotEmpty("") // Ложь
// М1сAIОбщие.NotEmpty("Текст") // Истина
// М1сAIОбщие.NotEmpty(Справочники.Номенклатура.ПустаяСсылка()) // Ложь
#EndRegion
#EndRegion

#Region М1сAIОбщие_Empty
/// <summary>
/// Проверяет, что значение пустое.
/// </summary>
/// <param name="Значение" type="Arbitrary">Проверяемое значение.</param>
/// <returns type="Boolean">Истина если значение пустое.</returns>
Функция Empty(Значение) Экспорт
	Возврат НЕ NotEmpty(Значение);
КонецФункции
#Region examples_М1сAIОбщие_Empty
// Примеры:
// М1сAIОбщие.Empty("") // Истина
// М1сAIОбщие.Empty(Неопределено) // Истина
// М1сAIОбщие.Empty(Справочники.Номенклатура.ПустаяСсылка()) // Истина
#EndRegion
#EndRegion

#Region М1сAIОбщие_IsRef
/// <summary>
/// Проверяет, что это ссылка на объект (не примитивный тип).
/// </summary>
/// <param name="Значение" type="Arbitrary">Проверяемое значение.</param>
/// <returns type="Boolean">Истина если это ссылка.</returns>
Функция IsRef(Значение) Экспорт
	Если Значение = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Попытка
		// Если есть метод Пустая() - значит это ссылка
		Значение.Пустая();
		Возврат Истина;
	Исключение
		Возврат Ложь;
	КонецПопытки;
КонецФункции
#Region examples_М1сAIОбщие_IsRef
// Примеры:
// М1сAIОбщие.IsRef(Справочники.Номенклатура.НайтиПоКоду("001")) // Истина
// М1сAIОбщие.IsRef("Строка") // Ложь  
// М1сAIОбщие.IsRef(123) // Ложь
#EndRegion
#EndRegion

// =================================================================
// РАБОТА С КОЛЛЕКЦИЯМИ
// =================================================================

#Region М1сAIОбщие_Count
/// <summary>
/// Возвращает количество элементов в коллекции.
/// </summary>
/// <param name="Collection" type="Arbitrary">Коллекция (массив, список значений, таблица значений и т.д.).</param>
/// <returns type="Number">Количество элементов или 0 если не коллекция.</returns>
Функция Count(Collection) Экспорт
	Если Collection = Неопределено Тогда
		Возврат 0;
	КонецЕсли;
	
	Попытка
		Возврат Collection.Количество();
	Исключение
		Возврат 0;
	КонецПопытки;
КонецФункции
#Region examples_М1сAIОбщие_Count
// Примеры:
// Массив = Новый Массив;
// Массив.Добавить("Элемент");
// М1сAIОбщие.Count(Массив) // 1
// М1сAIОбщие.Count(Неопределено) // 0
#EndRegion
#EndRegion

#Region М1сAIОбщие_HasItems
/// <summary>
/// Проверяет, что коллекция не пустая.
/// </summary>
/// <param name="Collection" type="Arbitrary">Коллекция.</param>
/// <returns type="Boolean">Истина если есть элементы.</returns>
Функция HasItems(Collection) Экспорт
	Возврат Count(Collection) > 0;
КонецФункции
#Region examples_М1сAIОбщие_HasItems
// Примеры:
// СписокЗначений = Новый СписокЗначений;
// М1сAIОбщие.HasItems(СписокЗначений) // Ложь
// СписокЗначений.Добавить("Значение");
// М1сAIОбщие.HasItems(СписокЗначений) // Истина
#EndRegion
#EndRegion

#Region М1сAIОбщие_Clear
/// <summary>
/// Очищает коллекцию если это возможно.
/// </summary>
/// <param name="Collection" type="Arbitrary">Коллекция для очистки.</param>
Процедура Clear(Collection) Экспорт
	Если Collection = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Попытка
		Collection.Очистить();
	Исключение
		// Игнорируем если нельзя очистить
	КонецПопытки;
КонецПроцедуры
#Region examples_М1сAIОбщие_Clear
// Примеры:
// Массив = Новый Массив;
// Массив.Добавить("Элемент");
// М1сAIОбщие.Clear(Массив); // Массив теперь пустой
#EndRegion
#EndRegion

// =================================================================
// ЗАПОЛНЕНИЕ ОБЪЕКТОВ
// =================================================================

#Region М1сAIОбщие_FillObject
/// <summary>
/// Заполняет свойства объекта из структуры/другого объекта.
/// </summary>
/// <param name="Target" type="Arbitrary">Объект для заполнения.</param>
/// <param name="Source" type="Arbitrary">Источник данных (структура, строка таблицы и т.д.).</param>
/// <param name="Fields" type="String" optional="True">Список полей через запятую, если пусто - все поля источника.</param>
Процедура FillObject(Target, Source, Fields = "") Экспорт
	Если Target = Неопределено ИЛИ Source = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Попытка
		Если ПустаяСтрока(Fields) Тогда
			// Заполняем все доступные поля
			ЗаполнитьЗначенияСвойств(Target, Source);
		Иначе
			// Заполняем только указанные поля
			МассивПолей = СтрРазделить(Fields, ",", Ложь);
			Для Каждого Поле Из МассивПолей Цикл
				ИмяПоля = СокрЛП(Поле);
				Попытка
					ЗначениеПоля = Source[ИмяПоля];
					Target[ИмяПоля] = ЗначениеПоля;
				Исключение
					// Пропускаем поля, которые нельзя заполнить
				КонецПопытки;
			КонецЦикла;
		КонецЕсли;
	Исключение
		// В случае ошибки продолжаем работу
	КонецПопытки;
КонецПроцедуры
#Region examples_М1сAIОбщие_FillObject
// Примеры:
// НоваяОрганизация = Справочники.Организации.СоздатьЭлемент();
// ДанныеОрганизации = Новый Структура("Наименование,ИНН", "ООО Тест", "1234567890");
// М1сAIОбщие.FillObject(НоваяОрганизация, ДанныеОрганизации);
// // Или заполнить только определенные поля:
// М1сAIОбщие.FillObject(НоваяОрганизация, ДанныеОрганизации, "Наименование");
#EndRegion
#EndRegion

#Region М1сAIОбщие_ToStruct
/// <summary>
/// Создает структуру из объекта.
/// </summary>
/// <param name="Source" type="Arbitrary">Исходный объект.</param>
/// <param name="Fields" type="String" optional="True">Список полей через запятую, если пусто - все поля.</param>
/// <returns type="Structure">Структура с данными объекта.</returns>
Функция ToStruct(Source, Fields = "") Экспорт
	Результат = Новый Структура;
	
	Если Empty(Source) Тогда
		Возврат Результат;
	КонецЕсли;
	
	// Попробуем получить метаданные
	Попытка
		МетаданныеОбъекта = Source.Метаданные();
	Исключение
		МетаданныеОбъекта = Неопределено;
	КонецПопытки;
	
	МассивПолей = ?(ПустаяСтрока(Fields), Неопределено, СтрРазделить(Fields, ","));
	
	// Если метаданные не получены — это не объект 1С
	Если МетаданныеОбъекта = Неопределено Тогда
		
		Если ТипЗнч(Source) = Тип("Структура") Тогда
			Для Каждого Пара Из Source Цикл
				
				Попытка                                         
					Имя = Пара.Ключ;
					Если МассивПолей = Неопределено Или МассивПолей.Найти(Имя) <> Неопределено Тогда
						Результат.Вставить(Пара.Ключ, Пара.Значение);
					КонецЕсли;	
					
				Исключение
					// Пропускаем
				КонецПопытки;
				
			КонецЦикла;	
		КонецЕсли;	
		
		Возврат Результат;
	КонецЕсли;
	
	// Получаем список реквизитов
	Попытка
		
		ИменаРеквизитов = Новый Массив;
		
		СтандартныеРеквизиты = МетаданныеОбъекта.СтандартныеРеквизиты;
		Для Каждого Реквизит Из СтандартныеРеквизиты Цикл
			Имя = Реквизит.Имя;
			
			Если МассивПолей = Неопределено Или МассивПолей.Найти(Имя) <> Неопределено Тогда
				ИменаРеквизитов.Добавить(Имя);
			КонецЕсли;	
			
		КонецЦикла;	
		
		Реквизиты = МетаданныеОбъекта.Реквизиты;
		Для Каждого Реквизит Из Реквизиты Цикл
			Имя = Реквизит.Имя;
			Если МассивПолей = Неопределено Или МассивПолей.Найти(Имя) <> Неопределено Тогда
				ИменаРеквизитов.Добавить(Имя);
			КонецЕсли;
			
		КонецЦикла;	                                
	Исключение
		Возврат Результат;
	КонецПопытки;
	
	// Заполняем структуру
	Для Каждого Имя Из ИменаРеквизитов Цикл
		
		Попытка
			Результат.Вставить(Имя, Source[Имя]);
		Исключение
			// Пропускаем
		КонецПопытки;
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

#Region examples_М1сAIОбщие_ToStruct
// Примеры:
// Организация = Справочники.Организации.НайтиПоКоду("001");
// Структура = М1сAIОбщие.ToStruct(Организация);
// // Или только определенные поля:
// СтруктураИНН = М1сAIОбщие.ToStruct(Организация, "Наименование,ИНН");
#EndRegion
#EndRegion

// =================================================================
// РАБОТА СО СТРОКАМИ
// =================================================================

#Region М1сAIОбщие_Coalesce
/// <summary>
/// Возвращает первое непустое значение из списка.
/// </summary>
/// <param name="Знач1" type="Arbitrary">Первое значение для проверки.</param>
/// <param name="Знач2" type="Arbitrary" optional="True">Второе значение для проверки.</param>
/// <param name="Знач3" type="Arbitrary" optional="True">Третье значение для проверки.</param>
/// <param name="Знач4" type="Arbitrary" optional="True">Четвертое значение для проверки.</param>
/// <param name="Знач5" type="Arbitrary" optional="True">Пятое значение для проверки.</param>
/// <returns type="Arbitrary">Первое непустое значение или Неопределено.</returns>
Функция Coalesce(Знач1, Знач2 = Неопределено, Знач3 = Неопределено, Знач4 = Неопределено, Знач5 = Неопределено) Экспорт
	Если NotEmpty(Знач1) Тогда
		Возврат Знач1;
	КонецЕсли;
	
	Если NotEmpty(Знач2) Тогда
		Возврат Знач2;
	КонецЕсли;
	
	Если NotEmpty(Знач3) Тогда
		Возврат Знач3;
	КонецЕсли;
	
	Если NotEmpty(Знач4) Тогда
		Возврат Знач4;
	КонецЕсли;
	
	Если NotEmpty(Знач5) Тогда
		Возврат Знач5;
	КонецЕсли;
	
	Возврат Неопределено;
КонецФункции
#Region examples_М1сAIОбщие_Coalesce
// Примеры:
// ИмяПользователя = М1сAIОбщие.Coalesce(
//     ПараметрыСеанса.ИмяПользователя,
//     ПользователиИнформационнойБазы.ТекущийПользователь().Имя,
//     "Гость"
// );
#EndRegion
#EndRegion

#Region М1сAIОбщие_StrDefault
/// <summary>
/// Возвращает строку или значение по умолчанию если строка пустая.
/// </summary>
/// <param name="Str" type="String">Исходная строка.</param>
/// <param name="DefaultValue" type="String" optional="True">Значение по умолчанию.</param>
/// <returns type="String">Исходная строка или значение по умолчанию.</returns>
Функция StrDefault(Str, DefaultValue = "") Экспорт
	Если ПустаяСтрока(Str) Тогда
		Возврат DefaultValue;
	КонецЕсли;
	Возврат Str;
КонецФункции
#Region examples_М1сAIОбщие_StrDefault
// Примеры:
// Наименование = М1сAIОбщие.StrDefault(Организация.Наименование, "Без названия");
// Описание = М1сAIОбщие.StrDefault(Товар.Описание, "Описание отсутствует");
#EndRegion
#EndRegion

// =================================================================
// РАБОТА С ДАТАМИ
// =================================================================

#Region М1сAIОбщие_Now
/// <summary>
/// Возвращает текущую дату сеанса (серверное время на сервере, локальное на клиенте).
/// </summary>
/// <returns type="Date">Текущая дата.</returns>
Функция Now() Экспорт
	#Если Сервер Тогда
		//Возврат ТекущаяДатаСеанса();
		Возврат ТекущаяДата();
	#Иначе
		Возврат ТекущаяДата();
	#КонецЕсли
КонецФункции
#Region examples_М1сAIОбщие_Now
// Примеры:
// ТекущаяДата = М1сAIОбщие.Now();
// // На сервере вернет ТекущаяДатаСеанса(), на клиенте ТекущаяДата()
#EndRegion
#EndRegion

#Region М1сAIОбщие_DateOrEmpty
/// <summary>
/// Возвращает дату или пустую дату если значение пустое.
/// </summary>
/// <param name="ЗначениеДаты" type="Arbitrary">Значение даты.</param>
/// <returns type="Date">Дата или '00010101' если пустое.</returns>
Функция DateOrEmpty(ЗначениеДаты) Экспорт
	Если Empty(ЗначениеДаты) Тогда
		Возврат '00010101';
	КонецЕсли;
	Возврат ЗначениеДаты;
КонецФункции
#Region examples_М1сAIОбщие_DateOrEmpty
// Примеры:
// ДатаЗавершения = М1сAIОбщие.DateOrEmpty(Задача.ДатаЗавершения);
// // Вернет дату или '00010101' если не заполнена
#EndRegion
#EndRegion

// =================================================================
// РАБОТА С ЧИСЛАМИ
// =================================================================

#Region М1сAIОбщие_NumOrZero
/// <summary>
/// Возвращает число или 0 если значение пустое/некорректное.
/// </summary>
/// <param name="ЗначениеЧисла" type="Arbitrary">Значение числа.</param>
/// <returns type="Number">Число или 0.</returns>
Функция NumOrZero(ЗначениеЧисла) Экспорт
	Если Empty(ЗначениеЧисла) Тогда
		Возврат 0;
	КонецЕсли;
	
	Попытка
		Возврат Число(ЗначениеЧисла);
	Исключение
		Возврат 0;
	КонецПопытки;
КонецФункции
#Region examples_М1сAIОбщие_NumOrZero
// Примеры:
// Количество = М1сAIОбщие.NumOrZero(СтрокаТаблицы.Количество);
// Сумма = М1сAIОбщие.NumOrZero("123.45"); // 123.45
// СуммаНекорректная = М1сAIОбщие.NumOrZero("abc"); // 0
#EndRegion
#EndRegion

#Region М1сAIОбщие_RoundNum
/// <summary>
/// Округляет число до указанного количества знаков.
/// </summary>
/// <param name="ЗначениеЧисла" type="Number">Исходное число.</param>
/// <param name="КоличествоЗнаков" type="Number" optional="True">Количество знаков после запятой (по умолчанию 2).</param>
/// <returns type="Number">Округленное число.</returns>
Функция RoundNum(ЗначениеЧисла, КоличествоЗнаков = 2) Экспорт
	Возврат Окр(ЗначениеЧисла, КоличествоЗнаков);
КонецФункции
#Region examples_М1сAIОбщие_RoundNum
// Примеры:
// Сумма = М1сAIОбщие.RoundNum(123.456789, 2); // 123.46
// Процент = М1сAIОбщие.RoundNum(15.678, 1); // 15.7
// ОкруглениеДоЦелых = М1сAIОбщие.RoundNum(123.789, 0); // 124
#EndRegion
#EndRegion

#КонецОбласти

#Область Examples

// =================================================================
// ОБЩИЕ ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ
// =================================================================

#Region М1сAIОбщие_ExamplesUsage
/// <summary>
/// Общие примеры использования модуля М1сAIОбщие.
/// </summary>
Процедура ExamplesUsage() Экспорт
	
	// === Проверки пустоты ===
	//Если М1сAIОбщие.NotEmpty(ПараметрыСеанса.ТекущийПользователь) Тогда
	//    М1сAIСтроки.Print("Пользователь авторизован");
	//КонецЕсли;
	
	// === Работа с коллекциями ===
	Массив = Новый Массив;
	Массив.Добавить("Элемент1");
	Массив.Добавить("Элемент2");
	
	Если М1сAIОбщие.HasItems(Массив) Тогда
		М1сAIСтроки.Print("В массиве " + М1сAIОбщие.Count(Массив) + " элементов");
	КонецЕсли;
	
	// === Заполнение объектов ===
	//НоваяОрганизация = Справочники.Организации.СоздатьЭлемент();
	//ДанныеОрганизации = Новый Структура("Наименование,ИНН", "ООО Тест", "1234567890");
	//М1сAIОбщие.FillObject(НоваяОрганизация, ДанныеОрганизации);
	
	// === Coalesce (первое непустое) ===
	//ИмяПользователя = М1сAIОбщие.Coalesce(
	//    ПараметрыСеанса.ИмяПользователя,
	//    ПользователиИнформационнойБазы.ТекущийПользователь().Имя,
	//    "Гость"
	//);
	
	// === Работа с числами ===
	Сумма = М1сAIОбщие.RoundNum(М1сAIОбщие.NumOrZero("123.456789"), 2); // = 123.46
	
КонецПроцедуры
#EndRegion

#КонецОбласти

// =================================================================
// РАБОТА С КЛЮЧАМИ СТРУКТУР
// =================================================================

#Region М1сAIОбщие_RemoveKeys
/// <summary>
/// Удаляет указанные ключи из структуры.
/// </summary>
/// <param name="Struct" type="Structure">Структура для изменения.</param>
/// <param name="Keys" type="String,Array">Ключи для удаления (строка через запятую или массив).</param>
/// <param name="ModifyOriginal" type="Boolean" optional="True">Изменять исходную структуру (по умолчанию Ложь - создается копия).</param>
/// <returns type="Structure">Структура без указанных ключей.</returns>
Функция RemoveKeys(Struct, Keys, ModifyOriginal = Ложь) Экспорт
	Если ТипЗнч(Struct) <> Тип("Структура") Тогда
		Возврат Новый Структура;
	КонецЕсли;
	
	// Определяем, работаем с оригиналом или копией
	Результат = ?(ModifyOriginal, Struct, Новый Структура);
	
	// Если создаем копию - копируем все поля
	Если НЕ ModifyOriginal Тогда
		Для Каждого Пара Из Struct Цикл
			Результат.Вставить(Пара.Ключ, Пара.Значение);
		КонецЦикла;
	КонецЕсли;
	
	// Определяем массив ключей для удаления
	МассивКлючей = Неопределено;
	
	Если ТипЗнч(Keys) = Тип("Строка") Тогда
		МассивКлючей = СтрРазделить(Keys, ",", Ложь);
		// Убираем пробелы
		Для Индекс = 0 По МассивКлючей.ВГраница() Цикл
			МассивКлючей[Индекс] = СокрЛП(МассивКлючей[Индекс]);
		КонецЦикла;
	ИначеЕсли ТипЗнч(Keys) = Тип("Массив") Тогда
		МассивКлючей = Keys;
	Иначе
		Возврат Результат;
	КонецЕсли;
	
	// Удаляем ключи
	Для Каждого Ключ Из МассивКлючей Цикл
		Если НЕ ПустаяСтрока(Ключ) И Результат.Свойство(Ключ) Тогда
			Результат.Удалить(Ключ);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
КонецФункции
#Region examples_М1сAIОбщие_RemoveKeys
// Примеры:
// Структура = Новый Структура("Наименование,Код,Ссылка,ВерсияДанных", "Товар", "001", СсылкаТовара, 15);
// 
// 1) Удаление служебных полей (создается копия):
// БезСлужебных = М1сAIОбщие.RemoveKeys(Структура, "Ссылка,ВерсияДанных");
//
// 2) Удаление из исходной структуры:
// М1сAIОбщие.RemoveKeys(Структура, "Код,ВерсияДанных", Истина);
//
// 3) Удаление через массив:
// СлужебныеПоля = Новый Массив;
// СлужебныеПоля.Добавить("Ссылка");
// СлужебныеПоля.Добавить("ВерсияДанных");
// БезСлужебных = М1сAIОбщие.RemoveKeys(Структура, СлужебныеПоля);
//
// 4) Стандартные наборы для удаления:
// БезСтандартных = М1сAIОбщие.RemoveKeys(Структура, М1сAIОбщие.StandardSystemKeys());
#EndRegion
#EndRegion

#Region М1сAIОбщие_StandardSystemKeys
/// <summary>
/// Возвращает список стандартных системных ключей, которые обычно нужно исключать при создании новых объектов.
/// </summary>
/// <returns type="String">Строка с ключами через запятую.</returns>
Функция StandardSystemKeys() Экспорт
	// Стандартные поля, которые обычно не нужны при создании нового объекта
	Возврат "Ссылка,ВерсияДанных,ПометкаУдаления,Предопределенный,ЭтоГруппа,Родитель,Код,Номер,Дата,Проведен,Статус";
КонецФункции
#Region examples_М1сAIОбщие_StandardSystemKeys
// Примеры:
// СтруктураОбъекта = М1сAIОбщие.ToStruct(СправочникЭлемент);
// БезСистемных = М1сAIОбщие.RemoveKeys(СтруктураОбъекта, М1сAIОбщие.StandardSystemKeys());
// // Остались только пользовательские реквизиты
#EndRegion
#EndRegion

#Region М1сAIОбщие_CleanStructForNew
/// <summary>
/// Очищает структуру от служебных полей для создания нового объекта.
/// Удаляет стандартные системные поля и устанавливает нужный тип.
/// </summary>
/// <param name="Struct" type="Structure">Исходная структура.</param>
/// <param name="NewType" type="String" optional="True">Тип нового объекта (например "Справочник.Номенклатура").</param>
/// <returns type="Structure">Очищенная структура, готовая для создания нового объекта.</returns>
Функция CleanStructForNew(Struct, NewType = "") Экспорт
	// Удаляем стандартные системные поля
	Результат = RemoveKeys(Struct, StandardSystemKeys());
	
	// Устанавливаем новый тип если указан
	Если НЕ ПустаяСтрока(NewType) Тогда
		Результат.Вставить("_Тип", NewType);
	КонецЕсли;
	
	Возврат Результат;
КонецФункции
#Region examples_М1сAIОбщие_CleanStructForNew
// Примеры:
// ИсходныйТовар = Справочники.Номенклатура.НайтиПоКоду("001");
// СтруктураТовара = М1сAIОбщие.ToStruct(ИсходныйТовар);
// 
// // Подготавливаем для создания нового элемента
// СтруктураДляНового = М1сAIОбщие.CleanStructForNew(СтруктураТовара, "Справочник.Номенклатура");
// НовыйТовар = М1сAIОбщие.FromStruct(СтруктураДляНового);
// НовыйТовар.Наименование = НовыйТовар.Наименование + " (Копия)";
// НовыйТовар.Записать();
#EndRegion
#EndRegion

// =================================================================
// ДОПОЛНЕНИЯ ДЛЯ МОДУЛЯ М1сAIОбщие
// Функции: TransformStruct, FromStruct, RemoveKeys
// =================================================================

// =================================================================
// ТРАНСФОРМАЦИЯ СТРУКТУР
// =================================================================

#Region М1сAIОбщие_TransformStruct
/// <summary>
/// Трансформирует структуру согласно карте соответствий (переименование ключей).
/// </summary>
/// <param name="SourceStruct" type="Structure">Исходная структура.</param>
/// <param name="TransformMap" type="Structure">Карта трансформации. Ключ - старое имя, Значение - новое имя.</param>
/// <param name="KeepUnmapped" type="Boolean" optional="True">Оставлять поля, не указанные в карте (по умолчанию Истина).</param>
/// <returns type="Structure">Трансформированная структура.</returns>
Функция TransformStruct(SourceStruct, TransformMap, KeepUnmapped = Истина) Экспорт
	Результат = Новый Структура;
	
	Если ТипЗнч(SourceStruct) <> Тип("Структура") Тогда
		Возврат Результат;
	КонецЕсли;
	
	Если ТипЗнч(TransformMap) <> Тип("Структура") Тогда
		// Если карта трансформации не передана, возвращаем копию исходной структуры
		Для Каждого Пара Из SourceStruct Цикл
			Результат.Вставить(Пара.Ключ, Пара.Значение);
		КонецЦикла;
		Возврат Результат;
	КонецЕсли;
	
	// Сначала обрабатываем поля из карты трансформации
	Для Каждого МапПара Из TransformMap Цикл
		СтароеИмя = МапПара.Ключ;
		НовоеИмя = МапПара.Значение;
		
		Если SourceStruct.Свойство(СтароеИмя) Тогда
			Значение = SourceStruct[СтароеИмя];
			
			// Если новое имя пустое или Неопределено - исключаем поле
			Если НЕ ПустаяСтрока(НовоеИмя) И НовоеИмя <> Неопределено Тогда
				Результат.Вставить(НовоеИмя, Значение);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	// Если нужно оставить немаппированные поля
	Если KeepUnmapped Тогда
		Для Каждого Пара Из SourceStruct Цикл
			ИмяПоля = Пара.Ключ;
			
			// Если поле не было в карте трансформации - добавляем как есть
			Если НЕ TransformMap.Свойство(ИмяПоля) Тогда
				Результат.Вставить(ИмяПоля, Пара.Значение);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат Результат;
КонецФункции
#Region examples_М1сAIОбщие_TransformStruct
// Примеры:
// ИсходнаяСтруктура = Новый Структура("Подразделение,Контрагент,Сумма", ОтделПродаж, ООО_Рога, 1000);
// КартаТрансформации = Новый Структура("Подразделение,Контрагент", "ПодразделениеОрг,КлиентПоставщик");
// НоваяСтруктура = М1сAIОбщие.TransformStruct(ИсходнаяСтруктура, КартаТрансформации);
// // Результат: ПодразделениеОрг=ОтделПродаж, КлиентПоставщик=ООО_Рога, Сумма=1000
//
// // Исключение полей (передаем пустую строку или Неопределено):
// КартаИсключения = Новый Структура("УстаревшееПоле", "");
// СтруктураБезПоля = М1сAIОбщие.TransformStruct(ИсходнаяСтруктура, КартаИсключения);
#EndRegion
#EndRegion

// =================================================================
// СОЗДАНИЕ ОБЪЕКТОВ ИЗ СТРУКТУР
// =================================================================

#Region М1сAIОбщие_FromStruct
/// <summary>
/// Создает или обновляет объект 1С на основе структуры.
/// Тип объекта определяется по полю "_Тип" или по "Ссылка".
/// </summary>
/// <param name="Struct" type="Structure">Структура с данными. Должна содержать "_Тип" или "Ссылка".</param>
/// <returns type="Object">Созданный или обновлённый объект 1С.</returns>
Функция FromStruct(Struct) Экспорт
	Если ТипЗнч(Struct) <> Тип("Структура") Тогда
		Возврат Неопределено;
	КонецЕсли;

	ТипСтрока = "";
	СоздаватьНовый = Истина;

	// Если явно указан тип — используем
	Если Struct.Свойство("_Тип") Тогда
		ТипСтрока = Struct["_Тип"];
	
	// Иначе — попытаемся определить по ссылке
	ИначеЕсли Struct.Свойство("Ссылка") Тогда
		Ссылка = Struct["Ссылка"];
		Если NotEmpty(Ссылка) Тогда
			Попытка
				МетаданныеОбъекта = Ссылка.Метаданные();
				ТипСтрока = МетаданныеОбъекта.ПолноеИмя(); // Например "Справочник.Контрагенты"
				СоздаватьНовый = Ложь; // Будем обновлять существующий
			Исключение
				Возврат Неопределено;
			КонецПопытки;
		КонецЕсли;
	КонецЕсли;

	Если ПустаяСтрока(ТипСтрока) Тогда
		Возврат Неопределено;
	КонецЕсли;

	// Разбираем строку типа
	ЧастиТипа = СтрРазделить(ТипСтрока, ".");
	Если ЧастиТипа.Количество() < 2 Тогда
		Возврат Неопределено;
	КонецЕсли;

	КатегорияОбъекта = ЧастиТипа[0];
	ИмяТипа = ЧастиТипа[1];

	// Получаем объект для заполнения
	Объект = Неопределено;
	
	#Если НЕ ТонкийКлиент Тогда
	Попытка
		Если НЕ СоздаватьНовый И Struct.Свойство("Ссылка") Тогда
			// Обновляем существующий объект
			Ссылка = Struct["Ссылка"];
			Если NotEmpty(Ссылка) Тогда
				Объект = Ссылка.ПолучитьОбъект();
			КонецЕсли;
		КонецЕсли;
		
		// Если не получилось получить объект по ссылке - создаем новый
		Если Объект = Неопределено Тогда
			Если КатегорияОбъекта = "Справочник" Тогда
				Объект = Справочники[ИмяТипа].СоздатьЭлемент();
			ИначеЕсли КатегорияОбъекта = "Документ" Тогда
				Объект = Документы[ИмяТипа].СоздатьДокумент();
			ИначеЕсли КатегорияОбъекта = "ПланВидовХарактеристик" Тогда
				Объект = ПланыВидовХарактеристик[ИмяТипа].СоздатьЭлемент();
			ИначеЕсли КатегорияОбъекта = "ПланСчетов" Тогда
				Объект = ПланыСчетов[ИмяТипа].СоздатьЭлемент();
			ИначеЕсли КатегорияОбъекта = "ПланВидовРасчета" Тогда
				Объект = ПланыВидовРасчета[ИмяТипа].СоздатьЭлемент();
			ИначеЕсли КатегорияОбъекта = "ПланОбмена" Тогда
				Объект = ПланыОбмена[ИмяТипа].СоздатьУзел();
			ИначеЕсли КатегорияОбъекта = "БизнесПроцесс" Тогда
				Объект = БизнесПроцессы[ИмяТипа].СоздатьБизнесПроцесс();
			ИначеЕсли КатегорияОбъекта = "Задача" Тогда
				Объект = Задачи[ИмяТипа].СоздатьЗадачу();
			Иначе
				Возврат Неопределено;
			КонецЕсли;
		КонецЕсли;
		
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	#Иначе
		// На тонком клиенте создание объектов недоступно
		Возврат Неопределено;
	#КонецЕсли

	Если Объект = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;

	// Заполняем объект данными из структуры
	Для Каждого Пара Из Struct Цикл
		ИмяПоля = Пара.Ключ;

		// Пропускаем служебные поля
		Если Лев(ИмяПоля, 1) = "_" Тогда
			Продолжить;
		КонецЕсли;

		Если ИмяПоля = "Ссылка" Тогда
			Продолжить; // Уже использовали
		КонецЕсли;

		Попытка
			Объект[ИмяПоля] = Пара.Значение;
		Исключение
			// Пропускаем поля, которые нельзя записать
		КонецПопытки;
	КонецЦикла;

	Возврат Объект;
КонецФункции
#Region examples_М1сAIОбщие_FromStruct
// Примеры:
// 
// 1) Создание нового объекта по типу:
// Структура = Новый Структура;
// Структура.Вставить("_Тип", "Справочник.Номенклатура");
// Структура.Вставить("Наименование", "Новая позиция");
// Структура.Вставить("Код", "001");
// Элемент = М1сAIОбщие.FromStruct(Структура);
// Элемент.Записать();
//
// 2) Обновление существующего объекта по ссылке:
// СуществующийТовар = Справочники.Номенклатура.НайтиПоКоду("001");
// Структура = Новый Структура;
// Структура.Вставить("Ссылка", СуществующийТовар);
// Структура.Вставить("Наименование", "Обновленное название");
// Элемент = М1сAIОбщие.FromStruct(Структура);
// Элемент.Записать();
//
// 3) Использование с ToStruct и TransformStruct:
// // Получаем структуру из документа одной конфигурации
// ИсходныйДокумент = Документы.ПоступлениеТоваровУслуг.НайтиПоНомеру("001");
// СтруктураИсходная = М1сAIОбщие.ToStruct(ИсходныйДокумент);
// 
// // Трансформируем под другую конфигурацию
// КартаТрансформации = Новый Структура("Подразделение,Контрагент", "ПодразделениеОрг,Поставщик");
// СтруктураТрансформированная = М1сAIОбщие.TransformStruct(СтруктураИсходная, КартаТрансформации);
// СтруктураТрансформированная.Вставить("_Тип", "Документ.ПоступлениеМатериалов");
//
// // Создаем документ в новой конфигурации
// НовыйДокумент = М1сAIОбщие.FromStruct(СтруктураТрансформированная);
// НовыйДокумент.Записать();
#EndRegion
#EndRegion

// =================================================================
// КЛЮЧИ КОЛЛЕКЦИЙ        Соответствие И Структура
// =================================================================

/// <summary>Возвращает массив ключей коллекции.</summary>
/// <remarks>
/// Поддерживаемые типы: <c>Соответствие</c> и <c>Структура</c>.
/// Для других типов и для <c>Неопределено</c> возвращается пустой массив без ошибок.
/// Порядок ключей соответствует порядку обхода коллекции.
/// </remarks>
/// <param name="Коллекция" type="Соответствие|Структура|Неопределено">
/// Коллекция, из которой нужно получить ключи.
/// </param>
/// <returns type="Массив">Массив ключей (возможно пустой).</returns>
/// <example>
/// <code>
/// Маппинг = Новый Соответствие;
/// Маппинг.Вставить("Колонка1", "Col1");
/// Маппинг.Вставить("Колонка2", "Col2");
/// Имена = М1сAIОбщие.Ключи(Маппинг); // ["Колонка1", "Колонка2"]
///
/// Стр = Новый Структура("A,B", 1, 2);
/// Имена2 = М1сAIОбщие.Ключи(Стр); // ["A", "B"]
/// </code>
/// </example>
Функция Ключи(Коллекция) Экспорт
	Результат = Новый Массив;
	
	Если Коллекция = Неопределено Тогда
		Возврат Результат;
	КонецЕсли;
	
	ТипКол = ТипЗнч(Коллекция);
	Если ТипКол = Тип("Соответствие") ИЛИ ТипКол = Тип("Структура") Тогда
		Для Каждого Пара Из Коллекция Цикл
			Результат.Добавить(Пара.Ключ);
		КонецЦикла;
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

// =================================================================
// РАБОТА С ТАБЛИЧНЫМИ ДАННЫМИ
// =================================================================

//#Область Работа_с_табличными_данными

//#Если Сервер Тогда
//	// Быстрая загрузка данных из одной таблицы в другую
//	//
//	// Параметры:
//	//  ТаблицаИсточник - ТаблицаЗначений, Результат запроса, ДеревоЗначений - источник данных
//	//  ТаблицаПриемник - ТаблицаЗначений, ДеревоЗначений - таблица, в которую загружаются данные
//	//  Очищать - Булево - если Истина, то таблица-приемник будет очищена перед загрузкой
//	//             по умолчанию: Ложь (слияние без очистки)
//	//
//	// Возвращаемое значение:
//	//  Число - количество загруженных строк
//	//
//	Функция ЗагрузитьВТаблицу(ТаблицаИсточник, ТаблицаПриемник, Знач Очищать = Ложь) Экспорт
//		
//		Если ТаблицаИсточник = Неопределено Или ТаблицаПриемник = Неопределено Тогда
//			ВызватьИсключение "Параметры ТаблицаИсточник и ТаблицаПриемник должны быть заполнены";
//		КонецЕсли;
//		
//		КоличествоСтрок = ТаблицаИсточник.Количество();
//		Если КоличествоСтрок = 0 Тогда
//			Если Очищать Тогда
//				ТаблицаПриемник.Очистить();
//			КонецЕсли;
//			Возврат 0;
//		КонецЕсли;
//		
//		// Очищаем приемник если требуется
//		Если Очищать Тогда
//			ТаблицаПриемник.Очистить();
//		КонецЕсли;
//		
//		// Получаем колонки для загрузки (пересечение колонок источника и приемника)
//		КолонкиДляЗагрузки = Новый Массив;
//		
//		Для Каждого КолонкаПриемника Из ТаблицаПриемник.Колонки Цикл
//			КолонкаИсточника = ТаблицаИсточник.Колонки.Найти(КолонкаПриемника.Имя);
//			Если КолонкаИсточника <> Неопределено Тогда
//				КолонкиДляЗагрузки.Добавить(КолонкаПриемника.Имя);
//			КонецЕсли;
//		КонецЦикла;
//		
//		Если КолонкиДляЗагрузки.Количество() = 0 Тогда
//			Возврат 0;
//		КонецЕсли;
//		
//		// Попытка использовать быструю загрузку через ЗагрузитьКолонку
//		// (работает только если приемник поддерживает этот метод и был очищен или пуст)
//		НачальноеКоличествоСтрокПриемника = ТаблицаПриемник.Количество();
//		
//		Попытка
//			// Проверяем, поддерживает ли приемник метод ЗагрузитьКолонку
//			// и можем ли мы использовать быструю загрузку
//			Если НачальноеКоличествоСтрокПриемника = 0 
//				И ТипЗнч(ТаблицаПриемник) = Тип("ТаблицаЗначений") Тогда
//				
//				// Быстрая загрузка по колонкам
//				ЗагрузитьТаблицуПоКолонкам(ТаблицаИсточник, ТаблицаПриемник, КолонкиДляЗагрузки, КоличествоСтрок);
//				Возврат КоличествоСтрок;
//				
//			КонецЕсли;
//		Исключение
//			// Если быстрая загрузка не сработала, используем построчную
//		КонецПопытки;
//		
//		// Построчная загрузка (медленный способ)
//		КоличествоЗагруженных = 0;
//		
//		Для Каждого СтрокаИсточника Из ТаблицаИсточник Цикл
//			НоваяСтрока = ТаблицаПриемник.Добавить();
//			
//			// Копируем значения только по совпадающим колонкам
//			Для Каждого ИмяКолонки Из КолонкиДляЗагрузки Цикл
//				НоваяСтрока[ИмяКолонки] = СтрокаИсточника[ИмяКолонки];
//			КонецЦикла;
//			
//			КоличествоЗагруженных = КоличествоЗагруженных + 1;
//		КонецЦикла;
//		
//		Возврат КоличествоЗагруженных;
//		
//	КонецФункции
//	
//	// Вспомогательная процедура для быстрой загрузки по колонкам
//	Процедура ЗагрузитьТаблицуПоКолонкам(ТаблицаИсточник, ТаблицаПриемник, КолонкиДляЗагрузки, КоличествоСтрок)
//		
//		// Предварительно добавляем нужное количество строк
//		Для Индекс = 1 По КоличествоСтрок Цикл
//			ТаблицаПриемник.Добавить();
//		КонецЦикла;
//		
//		// Загружаем данные по колонкам
//		Для Каждого ИмяКолонки Из КолонкиДляЗагрузки Цикл
//			МассивЗначений = ТаблицаИсточник.ВыгрузитьКолонку(ИмяКолонки);
//			ТаблицаПриемник.ЗагрузитьКолонку(МассивЗначений, ИмяКолонки);
//		КонецЦикла;
//		
//	КонецПроцедуры
//	
//	// Дополнительная функция для объединения структур колонок
//	// (полезна при подготовке таблиц-приемников)
//	Функция СоздатьТаблицуСОбщимиКолонками(ТаблицаИсточник, ДополнительныеКолонки = Неопределено) Экспорт
//		
//		НоваяТаблица = Новый ТаблицаЗначений;
//		
//		// Копируем колонки из источника
//		Для Каждого Колонка Из ТаблицаИсточник.Колонки Цикл
//			НоваяТаблица.Колонки.Добавить(Колонка.Имя, Колонка.ТипЗначения, Колонка.Заголовок, Колонка.Ширина);
//		КонецЦикла;
//		
//		// Добавляем дополнительные колонки если переданы
//		Если ДополнительныеКолонки <> Неопределено Тогда
//			Если ТипЗнч(ДополнительныеКолонки) = Тип("Структура") Тогда
//				Для Каждого КлючЗначение Из ДополнительныеКолонки Цикл
//					Если НоваяТаблица.Колонки.Найти(КлючЗначение.Ключ) = Неопределено Тогда
//						НоваяТаблица.Колонки.Добавить(КлючЗначение.Ключ, КлючЗначение.Значение);
//					КонецЕсли;
//				КонецЦикла;
//			ИначеЕсли ТипЗнч(ДополнительныеКолонки) = Тип("ТаблицаЗначений") Тогда
//				Для Каждого Колонка Из ДополнительныеКолонки.Колонки Цикл
//					Если НоваяТаблица.Колонки.Найти(Колонка.Имя) = Неопределено Тогда
//						НоваяТаблица.Колонки.Добавить(Колонка.Имя, Колонка.ТипЗначения, Колонка.Заголовок, Колонка.Ширина);
//					КонецЕсли;
//				КонецЦикла;
//			КонецЕсли;
//		КонецЕсли;
//		
//		Возврат НоваяТаблица;
//		
//	КонецФункции
//	
//	// Загрузка данных с фильтрацией
//	//
//	// Параметры:
//	//  ТаблицаИсточник - ТаблицаЗначений, Результат запроса, ДеревоЗначений - источник данных
//	//  ТаблицаПриемник - ТаблицаЗначений, ДеревоЗначений - таблица, в которую загружаются данные
//	//  Отбор - Структура - отбор по значениям полей (ключ = имя колонки, значение = искомое значение)
//	//         - Массив структур - несколько условий отбора (ИЛИ между структурами, И внутри структуры)
//	//         - Неопределено - без отбора
//	//  Очищать - Булево - если Истина, то таблица-приемник будет очищена перед загрузкой
//	//
//	// Возвращаемое значение:
//	//  Число - количество загруженных строк
//	//
//	// Примеры использования:
//	//  // Простой отбор по одному полю
//	//  Отбор = Новый Структура("Статус", "Активный");
//	//  М1сAIОбщие.ЗагрузитьВТаблицуСФильтром(Источник, Приемник, Отбор);
//	//
//	//  // Сложный отбор по нескольким полям
//	//  Отбор = Новый Структура("Статус,Тип", "Активный", "Основной");
//	//  М1сAIОбщие.ЗагрузитьВТаблицуСФильтром(Источник, Приемник, Отбор);
//	//
//	//  // Отбор по нескольким вариантам (ИЛИ)
//	//  МассивОтборов = Новый Массив;
//	//  МассивОтборов.Добавить(Новый Структура("Статус", "Активный"));
//	//  МассивОтборов.Добавить(Новый Структура("Статус", "Ожидает"));
//	//  М1сAIОбщие.ЗагрузитьВТаблицуСФильтром(Источник, Приемник, МассивОтборов);
//	//
//	Функция ЗагрузитьВТаблицуСФильтром(ТаблицаИсточник, ТаблицаПриемник, Отбор = Неопределено, Знач Очищать = Ложь) Экспорт
//		
//		#Если Сервер Тогда
//			Если ТаблицаИсточник = Неопределено Или ТаблицаПриемник = Неопределено Тогда
//				ВызватьИсключение "Параметры ТаблицаИсточник и ТаблицаПриемник должны быть заполнены";
//			КонецЕсли;
//			
//			КоличествоСтрок = ТаблицаИсточник.Количество();
//			Если КоличествоСтрок = 0 Тогда
//				Если Очищать Тогда
//					ТаблицаПриемник.Очистить();
//				КонецЕсли;
//				Возврат 0;
//			КонецЕсли;
//			
//			// Очищаем приемник если требуется
//			Если Очищать Тогда
//				ТаблицаПриемник.Очистить();
//			КонецЕсли;
//			
//			// Получаем колонки для загрузки
//			КолонкиДляЗагрузки = ПолучитьОбщиеКолонки(ТаблицаИсточник, ТаблицаПриемник);
//			Если КолонкиДляЗагрузки.Количество() = 0 Тогда
//				Возврат 0;
//			КонецЕсли;
//			
//			// Если отбор не задан, используем обычную загрузку
//			Если Отбор = Неопределено Тогда
//				Возврат ЗагрузитьВТаблицу(ТаблицаИсточник, ТаблицаПриемник, Ложь); // Очистка уже сделана выше
//			КонецЕсли;
//			
//			// Загружаем данные с применением отбора
//			КоличествоЗагруженных = 0;
//			
//			Для Каждого СтрокаИсточника Из ТаблицаИсточник Цикл
//				
//				Если ПроверитьСтрокуПоОтбору(СтрокаИсточника, Отбор) Тогда
//					НоваяСтрока = ТаблицаПриемник.Добавить();
//					
//					// Копируем значения только по совпадающим колонкам
//					Для Каждого ИмяКолонки Из КолонкиДляЗагрузки Цикл
//						НоваяСтрока[ИмяКолонки] = СтрокаИсточника[ИмяКолонки];
//					КонецЦикла;
//					
//					КоличествоЗагруженных = КоличествоЗагруженных + 1;
//				КонецЕсли;
//				
//			КонецЦикла;
//			
//			Возврат КоличествоЗагруженных;
//			
//		#Иначе
//			ВызватьИсключение "Функция ЗагрузитьВТаблицуСФильтром доступна только на сервере";
//		#КонецЕсли
//		
//	КонецФункции
//	
//	// Загрузка данных с маппингом (переименованием) колонок
//	//
//	// Параметры:
//	//  ТаблицаИсточник - ТаблицаЗначений, Результат запроса, ДеревоЗначений - источник данных
//	//  ТаблицаПриемник - ТаблицаЗначений, ДеревоЗначений - таблица, в которую загружаются данные
//	//  СоответствиеКолонок - Структура - соответствие колонок (ключ = имя в приемнике, значение = имя в источнике)
//	//                       - Соответствие - то же самое в виде соответствия
//	//  Очищать - Булево - если Истина, то таблица-приемник будет очищена перед загрузкой
//	//
//	// Возвращаемое значение:
//	//  Число - количество загруженных строк
//	//
//	// Примеры использования:
//	//  // Переименование колонок при загрузке
//	//  Маппинг = Новый Структура;
//	//  Маппинг.Вставить("Наименование", "Name");        // В приемнике "Наименование", в источнике "Name"  
//	//  Маппинг.Вставить("ДатаСоздания", "CreatedDate"); // В приемнике "ДатаСоздания", в источнике "CreatedDate"
//	//  Маппинг.Вставить("Активен", "IsActive");         // В приемнике "Активен", в источнике "IsActive"
//	//  М1сAIОбщие.ЗагрузитьВТаблицуСМаппингом(ТаблицаJSON, ТаблицаРусская, Маппинг);
//	//
//	Функция ЗагрузитьВТаблицуСМаппингом(ТаблицаИсточник, ТаблицаПриемник, СоответствиеКолонок, Знач Очищать = Ложь) Экспорт
//		
//		#Если Сервер Тогда
//			Если ТаблицаИсточник = Неопределено Или ТаблицаПриемник = Неопределено Тогда
//				ВызватьИсключение "Параметры ТаблицаИсточник и ТаблицаПриемник должны быть заполнены";
//			КонецЕсли;
//			
//			Если СоответствиеКолонок = Неопределено Тогда
//				ВызватьИсключение "Параметр СоответствиеКолонок должен быть заполнен";
//			КонецЕсли;
//			
//			КоличествоСтрок = ТаблицаИсточник.Количество();
//			Если КоличествоСтрок = 0 Тогда
//				Если Очищать Тогда
//					ТаблицаПриемник.Очистить();
//				КонецЕсли;
//				Возврат 0;
//			КонецЕсли;
//			
//			// Очищаем приемник если требуется
//			Если Очищать Тогда
//				ТаблицаПриемник.Очистить();
//			КонецЕсли;
//			
//			// Подготавливаем маппинг колонок
//			МаппингКолонок = ПодготовитьМаппингКолонок(ТаблицаИсточник, ТаблицаПриемник, СоответствиеКолонок);
//			Если МаппингКолонок.Количество() = 0 Тогда
//				Возврат 0;
//			КонецЕсли;
//			
//			// Загружаем данные с применением маппинга
//			КоличествоЗагруженных = 0;
//			
//			Для Каждого СтрокаИсточника Из ТаблицаИсточник Цикл
//				НоваяСтрока = ТаблицаПриемник.Добавить();
//				
//				// Копируем значения по маппингу колонок
//				Для Каждого ЭлементМаппинга Из МаппингКолонок Цикл
//					ИмяВПриемнике = ЭлементМаппинга.Ключ;
//					ИмяВИсточнике = ЭлементМаппинга.Значение;
//					НоваяСтрока[ИмяВПриемнике] = СтрокаИсточника[ИмяВИсточнике];
//				КонецЦикла;
//				
//				КоличествоЗагруженных = КоличествоЗагруженных + 1;
//			КонецЦикла;
//			
//			Возврат КоличествоЗагруженных;
//			
//		#Иначе
//			ВызватьИсключение "Функция ЗагрузитьВТаблицуСМаппингом доступна только на сервере";
//		#КонецЕсли
//		
//	КонецФункции
//	
//	// Комбинированная функция: загрузка с фильтром И маппингом одновременно
//	//
//	// Параметры:
//	//  ТаблицаИсточник - ТаблицаЗначений, Результат запроса, ДеревоЗначений - источник данных
//	//  ТаблицаПриемник - ТаблицаЗначений, ДеревоЗначений - таблица, в которую загружаются данные
//	//  СоответствиеКолонок - Структура/Соответствие - маппинг колонок (см. ЗагрузитьВТаблицуСМаппингом)
//	//  Отбор - Структура/Массив - отбор по значениям (см. ЗагрузитьВТаблицуСФильтром)
//	//  Очищать - Булево - очищать ли приемник перед загрузкой
//	//
//	// Возвращаемое значение:
//	//  Число - количество загруженных строк
//	//
//	Функция ЗагрузитьВТаблицуПолный(ТаблицаИсточник, ТаблицаПриемник, СоответствиеКолонок = Неопределено, Отбор = Неопределено, Знач Очищать = Ложь) Экспорт
//		
//		#Если Сервер Тогда
//			Если ТаблицаИсточник = Неопределено Или ТаблицаПриемник = Неопределено Тогда
//				ВызватьИсключение "Параметры ТаблицаИсточник и ТаблицаПриемник должны быть заполнены";
//			КонецЕсли;
//			
//			КоличествоСтрок = ТаблицаИсточник.Количество();
//			Если КоличествоСтрок = 0 Тогда
//				Если Очищать Тогда
//					ТаблицаПриемник.Очистить();
//				КонецЕсли;
//				Возврат 0;
//			КонецЕсли;
//			
//			// Очищаем приемник если требуется
//			Если Очищать Тогда
//				ТаблицаПриемник.Очистить();
//			КонецЕсли;
//			
//			// Определяем маппинг колонок
//			МаппингКолонок = Неопределено;
//			Если СоответствиеКолонок <> Неопределено Тогда
//				МаппингКолонок = ПодготовитьМаппингКолонок(ТаблицаИсточник, ТаблицаПриемник, СоответствиеКолонок);
//			Иначе
//				// Используем автоматическое сопоставление по именам
//				КолонкиДляЗагрузки = ПолучитьОбщиеКолонки(ТаблицаИсточник, ТаблицаПриемник);
//				МаппингКолонок = Новый Соответствие;
//				Для Каждого ИмяКолонки Из КолонкиДляЗагрузки Цикл
//					МаппингКолонок.Вставить(ИмяКолонки, ИмяКолонки);
//				КонецЦикла;
//			КонецЕсли;
//			
//			Если МаппингКолонок.Количество() = 0 Тогда
//				Возврат 0;
//			КонецЕсли;
//			
//			// Загружаем данные с применением отбора и маппинга
//			КоличествоЗагруженных = 0;
//			
//			Для Каждого СтрокаИсточника Из ТаблицаИсточник Цикл
//				
//				// Проверяем отбор (если задан)
//				Если Отбор <> Неопределено И Не ПроверитьСтрокуПоОтбору(СтрокаИсточника, Отбор) Тогда
//					Продолжить;
//				КонецЕсли;
//				
//				НоваяСтрока = ТаблицаПриемник.Добавить();
//				
//				// Копируем значения по маппингу колонок
//				Для Каждого ЭлементМаппинга Из МаппингКолонок Цикл
//					ИмяВПриемнике = ЭлементМаппинга.Ключ;
//					ИмяВИсточнике = ЭлементМаппинга.Значение;
//					НоваяСтрока[ИмяВПриемнике] = СтрокаИсточника[ИмяВИсточнике];
//				КонецЦикла;
//				
//				КоличествоЗагруженных = КоличествоЗагруженных + 1;
//			КонецЦикла;
//			
//			Возврат КоличествоЗагруженных;
//			
//		#Иначе
//			ВызватьИсключение "Функция ЗагрузитьВТаблицуПолный доступна только на сервере";
//		#КонецЕсли
//		
//	КонецФункции
//	
//	#Область ВспомогательныеФункции
//	
//	// Получение списка общих колонок между таблицами
//	Функция ПолучитьОбщиеКолонки(ТаблицаИсточник, ТаблицаПриемник)
//		
//		КолонкиДляЗагрузки = Новый Массив;
//		
//		Для Каждого КолонкаПриемника Из ТаблицаПриемник.Колонки Цикл
//			КолонкаИсточника = ТаблицаИсточник.Колонки.Найти(КолонкаПриемника.Имя);
//			Если КолонкаИсточника <> Неопределено Тогда
//				КолонкиДляЗагрузки.Добавить(КолонкаПриемника.Имя);
//			КонецЕсли;
//		КонецЦикла;
//		
//		Возврат КолонкиДляЗагрузки;
//		
//	КонецФункции
//	
//	// Проверка строки на соответствие условиям отбора
//	Функция ПроверитьСтрокуПоОтбору(Строка, Отбор)
//		
//		Если ТипЗнч(Отбор) = Тип("Структура") Тогда
//			// Простой отбор - все условия должны выполняться (И)
//			Для Каждого УсловиеОтбора Из Отбор Цикл
//				ИмяКолонки = УсловиеОтбора.Ключ;
//				ИскомоеЗначение = УсловиеОтбора.Значение;
//				
//				Если Строка[ИмяКолонки] <> ИскомоеЗначение Тогда
//					Возврат Ложь;
//				КонецЕсли;
//			КонецЦикла;
//			
//			Возврат Истина;
//			
//		ИначеЕсли ТипЗнч(Отбор) = Тип("Массив") Тогда
//			// Массив отборов - хотя бы один должен выполниться (ИЛИ)
//			Для Каждого ВариантОтбора Из Отбор Цикл
//				Если ПроверитьСтрокуПоОтбору(Строка, ВариантОтбора) Тогда
//					Возврат Истина;
//				КонецЕсли;
//			КонецЦикла;
//			
//			Возврат Ложь;
//		КонецЕсли;
//		
//		Возврат Истина;
//		
//	КонецФункции
//	
//	// Подготовка маппинга колонок с проверками
//	Функция ПодготовитьМаппингКолонок(ТаблицаИсточник, ТаблицаПриемник, СоответствиеКолонок)
//		
//		МаппингКолонок = Новый Соответствие;
//		
//		// Преобразуем структуру в соответствие если нужно
//		СоответствиеДляОбработки = СоответствиеКолонок;
//		Если ТипЗнч(СоответствиеКолонок) = Тип("Структура") Тогда
//			СоответствиеДляОбработки = Новый Соответствие;
//			Для Каждого КлючЗначение Из СоответствиеКолонок Цикл
//				СоответствиеДляОбработки.Вставить(КлючЗначение.Ключ, КлючЗначение.Значение);
//			КонецЦикла;
//		КонецЕсли;
//		
//		// Проверяем и подготавливаем маппинг
//		Для Каждого ЭлементСоответствия Из СоответствиеДляОбработки Цикл
//			ИмяВПриемнике = ЭлементСоответствия.Ключ;
//			ИмяВИсточнике = ЭлементСоответствия.Значение;
//			
//			// Проверяем существование колонок
//			КолонкаПриемника = ТаблицаПриемник.Колонки.Найти(ИмяВПриемнике);
//			КолонкаИсточника = ТаблицаИсточник.Колонки.Найти(ИмяВИсточнике);
//			
//			Если КолонкаПриемника <> Неопределено И КолонкаИсточника <> Неопределено Тогда
//				МаппингКолонок.Вставить(ИмяВПриемнике, ИмяВИсточнике);
//			КонецЕсли;
//		КонецЦикла;
//		
//		Возврат МаппингКолонок;
//		
//	КонецФункции
//	
//	#КонецОбласти	
//#КонецЕсли

//#КонецОбласти   

//#Область Работа_с_табличными_данными

//#Если Сервер Тогда
//	
//	// Быстрая загрузка/слияние данных: блочная по колонкам
//	// Параметры: см. прежнюю версию
//	Функция ЗагрузитьВТаблицу(ТаблицаИсточник, ТаблицаПриемник, Знач Очищать = Ложь) Экспорт
//		Если ТаблицаИсточник = Неопределено Или ТаблицаПриемник = Неопределено Тогда
//			ВызватьИсключение "Параметры ТаблицаИсточник и ТаблицаПриемник должны быть заполнены";
//		КонецЕсли;
//		
//		КоличествоНовых = ТаблицаИсточник.Количество();
//		Если КоличествоНовых = 0 Тогда
//			Если Очищать Тогда ТаблицаПриемник.Очистить(); КонецЕсли;
//			Возврат 0;
//		КонецЕсли;
//		
//		Маппинг = ПолучитьМаппингПоИменам(ТаблицаИсточник, ТаблицаПриемник);
//		Если Маппинг.Количество() = 0 Тогда Возврат 0; КонецЕсли;
//		
//		Если Очищать Или ТаблицаПриемник.Количество() = 0 Тогда
//			ТаблицаПриемник.Очистить();
//			ЗагрузитьВТаблицу_Колонками(ТаблицаИсточник, ТаблицаПриемник, Маппинг, КоличествоНовых);
//			Возврат КоличествоНовых;
//		Иначе
//			Старых = ТаблицаПриемник.Количество();
//			ИтогВсего = Старых + КоличествоНовых;
//			
//			Буфер = Новый ТаблицаЗначений;
//			Для Каждого К Из ТаблицаПриемник.Колонки Цикл
//				Буфер.Колонки.Добавить(К.Имя, К.ТипЗначения, К.Заголовок, К.Ширина);
//			КонецЦикла;
//			
//			Для i = 1 По ИтогВсего Цикл
//				Буфер.Добавить();
//			КонецЦикла;
//			
//			Для Каждого Пара Из Маппинг Цикл
//				ИмяВПриемнике = Пара.Ключ;
//				ИмяВИсточнике = Пара.Значение;
//				
//				Если Старых > 0 Тогда
//					МассивСтарых = ТаблицаПриемник.ВыгрузитьКолонку(ИмяВПриемнике);
//				Иначе
//					МассивСтарых = Новый Массив;
//				КонецЕсли;
//				
//				МассивНовых = ТаблицаИсточник.ВыгрузитьКолонку(ИмяВИсточнике);
//				
//				ВсеЗначения = Новый Массив;
//				Для Каждого v Из МассивСтарых Цикл ВсеЗначения.Добавить(v); КонецЦикла;
//				Для Каждого v Из МассивНовых Цикл ВсеЗначения.Добавить(v); КонецЦикла;
//				
//				Буфер.ЗагрузитьКолонку(ВсеЗначения, ИмяВПриемнике);
//			КонецЦикла;
//			
//			// ↓↓↓ ЗДЕСЬ ПРАВКА: собираем список имён колонок
//			КолонкиНазначения = Новый Массив;
//			Для Каждого Пара Из Маппинг Цикл
//				КолонкиНазначения.Добавить(Пара.Ключ);
//			КонецЦикла;
//			
//			ТаблицаПриемник.Очистить();
//			ЗагрузитьТаблицуПоКолонкам(Буфер, ТаблицаПриемник, КолонкиНазначения, ИтогВсего);
//			
//			Возврат КоличествоНовых;
//		КонецЕсли;
//	КонецФункции
//	
//	
//	Процедура ЗагрузитьТаблицуПоКолонкам(ТаблицаИсточник, ТаблицаПриемник, КолонкиНазначения, КоличествоСтрок)
//		Для i = 1 По КоличествоСтрок Цикл
//			ТаблицаПриемник.Добавить();
//		КонецЦикла;
//		
//		Для Каждого ИмяВПриемнике Из КолонкиНазначения Цикл
//			ИмяВИсточнике = ИмяВПриемнике;
//			Если ТипЗнч(ТаблицаИсточник) = Тип("ТаблицаЗначений")
//				И ТаблицаИсточник.Колонки.Найти(ИмяВИсточнике) = Неопределено Тогда
//				Продолжить;
//			КонецЕсли;
//			
//			МассивЗначений = ТаблицаИсточник.ВыгрузитьКолонку(ИмяВИсточнике);
//			ТаблицаПриемник.ЗагрузитьКолонку(МассивЗначений, ИмяВПриемнике);
//		КонецЦикла;
//	КонецПроцедуры
//	
//	// Универсальный блочный залив «источник → пустой приёмник» c маппингом
//	Процедура ЗагрузитьВТаблицу_Колонками(ТаблицаИсточник, ТаблицаПриемник, Маппинг, КоличествоСтрок)
//		Для i = 1 По КоличествоСтрок Цикл
//			ТаблицаПриемник.Добавить();
//		КонецЦикла;
//		
//		Для Каждого Пара Из Маппинг Цикл
//			ИмяВПриемнике = Пара.Ключ;
//			ИмяВИсточнике = Пара.Значение;
//			МассивЗначений = ТаблицаИсточник.ВыгрузитьКолонку(ИмяВИсточнике);
//			ТаблицаПриемник.ЗагрузитьКолонку(МассивЗначений, ИмяВПриемнике);
//		КонецЦикла;
//	КонецПроцедуры
//	
//	// Маппинг: ключ = имя в приёмнике, значение = имя в источнике (пересечение по именам)
//	Функция ПолучитьМаппингПоИменам(ТаблицаИсточник, ТаблицаПриемник)
//		Маппинг = Новый Соответствие;
//		Для Каждого КолонкаПриемника Из ТаблицаПриемник.Колонки Цикл
//			Если ТаблицаИсточник.Колонки.Найти(КолонкаПриемника.Имя) <> Неопределено Тогда
//				Маппинг.Вставить(КолонкаПриемника.Имя, КолонкаПриемника.Имя);
//			КонецЕсли;
//		КонецЦикла;
//		Возврат Маппинг;
//	КонецФункции
//	
//#КонецЕсли
//#КонецОбласти

#Область Работа_с_табличными_данными

#Если Сервер Тогда

///////////////////////////////////////////////////////////////////////////////
// Быстрая загрузка/слияние ТаблицаЗначений с выбором стратегии
///////////////////////////////////////////////////////////////////////////////

Функция ЗагрузитьВТаблицу(ТаблицаИсточник, ТаблицаПриемник, Знач Очищать = Ложь) Экспорт
	
	Если ТаблицаИсточник = Неопределено Или ТаблицаПриемник = Неопределено Тогда
		ВызватьИсключение "Параметры ТаблицаИсточник и ТаблицаПриемник должны быть заполнены";
	КонецЕсли;

	КоличествоНовых = ТаблицаИсточник.Количество();
	Если КоличествоНовых = 0 Тогда
		Если Очищать Тогда ТаблицаПриемник.Очистить(); КонецЕсли;
		Возврат 0;
	КонецЕсли;

	// сопоставление колонок: ключ = имя в приёмнике, значение = имя в источнике
	Маппинг = ПолучитьМаппингПоИменам(ТаблицаИсточник, ТаблицаПриемник);
	Если Маппинг.Количество() = 0 Тогда Возврат 0; КонецЕсли;

	Старых = ТаблицаПриемник.Количество();

	// === Очистка / пустой приёмник ===
	Если Очищать ИЛИ Старых = 0 Тогда
		ТаблицаПриемник.Очистить();
		БыстраяЗаливкаКолонками(ТаблицаИсточник, ТаблицаПриемник, Маппинг, КоличествоНовых);
		Возврат КоличествоНовых;
	КонецЕсли;

	// === MERGE: выбор стратегии ===
	Если Старых <= КоличествоНовых Тогда
		// Стратегия A: rebuild из новых + дозапись старых построчно (их мало)
		СнимокСтарых = СнимокСтрокПоКолонкам(ТаблицаПриемник, Ключи(Маппинг));

		ТаблицаПриемник.Очистить();
		БыстраяЗаливкаКолонками(ТаблицаИсточник, ТаблицаПриемник, Маппинг, КоличествоНовых);

		Для Каждого Стр Из СнимокСтарых Цикл
			Новая = ТаблицаПриемник.Добавить();
			Для Каждого П Из Стр Цикл
				Новая[П.Ключ] = П.Значение;
			КонецЦикла;
		КонецЦикла;

		Возврат КоличествоНовых;

	Иначе
		// Стратегия B: старых больше — склейка колоночными массивами
		ИтогВсего = Старых + КоличествоНовых;

		// Снимем «срез» старых значений по целевым колонкам
		СтарыеКолонки = Новый Соответствие;
		Для Каждого Пара Из Маппинг Цикл
			ИмяВПриемнике = Пара.Ключ;
			СтарыеКолонки.Вставить(ИмяВПриемнике, ТаблицаПриемник.ВыгрузитьКолонку(ИмяВПриемнике));
		КонецЦикла;

		// Добавим недостающее количество строк ровно один раз
		Дополнительно = ИтогВсего - Старых;
		Если Дополнительно > 0 Тогда
			Для i = 1 По Дополнительно Цикл
				ТаблицаПриемник.Добавить();
			КонецЦикла;
		КонецЕсли;

		// Формируем и заливаем значения для каждой колонки
		Для Каждого Пара Из Маппинг Цикл
			ИмяВПриемнике = Пара.Ключ;
			ИмяВИсточнике = Пара.Значение;

			МассивСтарых = СтарыеКолонки[ИмяВПриемнике];                  // длина = Старых
			МассивНовых  = ТаблицаИсточник.ВыгрузитьКолонку(ИмяВИсточнике); // длина = КоличествоНовых

			ВсеЗначения = Новый Массив(ИтогВсего);

			Для i = 0 По Старых - 1 Цикл
				ВсеЗначения[i] = МассивСтарых[i];
			КонецЦикла;
			Для j = 0 По КоличествоНовых - 1 Цикл
				ВсеЗначения[Старых + j] = МассивНовых[j];
			КонецЦикла;

			ТаблицаПриемник.ЗагрузитьКолонку(ВсеЗначения, ИмяВПриемнике);
		КонецЦикла;

		Возврат КоличествоНовых;
	КонецЕсли;
КонецФункции


///////////////////////////////////////////////////////////////////////////////
// Варианты: с фильтром / с маппингом / комбинированный
///////////////////////////////////////////////////////////////////////////////

Функция ЗагрузитьВТаблицуСФильтром(ТаблицаИсточник, ТаблицаПриемник, Отбор = Неопределено, Знач Очищать = Ложь) Экспорт
	Если ТаблицаИсточник = Неопределено Или ТаблицаПриемник = Неопределено Тогда
		ВызватьИсключение "Параметры ТаблицаИсточник и ТаблицаПриемник должны быть заполнены";
	КонецЕсли;

	КоличествоСтрок = ТаблицаИсточник.Количество();
	Если КоличествоСтрок = 0 Тогда
		Если Очищать Тогда ТаблицаПриемник.Очистить(); КонецЕсли;
		Возврат 0;
	КонецЕсли;

	Если Очищать Тогда ТаблицаПриемник.Очистить(); КонецЕсли;

	КолонкиДляЗагрузки = ПолучитьОбщиеКолонки(ТаблицаИсточник, ТаблицаПриемник);
	Если КолонкиДляЗагрузки.Количество() = 0 Тогда Возврат 0; КонецЕсли;

	Если Отбор = Неопределено Тогда
		Возврат ЗагрузитьВТаблицу(ТаблицаИсточник, ТаблицаПриемник, Ложь);
	КонецЕсли;

	// Фильтруем → буфер → быстрая заливка
	Буфер = Новый ТаблицаЗначений;
	Для Каждого К Из ТаблицаПриемник.Колонки Цикл
		Буфер.Колонки.Добавить(К.Имя, К.ТипЗначения, К.Заголовок, К.Ширина);
	КонецЦикла;

	Для Каждого СтрокаИсточника Из ТаблицаИсточник Цикл
		Если ПроверитьСтрокуПоОтбору(СтрокаИсточника, Отбор) Тогда
			Новая = Буфер.Добавить();
			Для Каждого ИмяКолонки Из КолонкиДляЗагрузки Цикл
				Новая[ИмяКолонки] = СтрокаИсточника[ИмяКолонки];
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;

	Итог = Буфер.Количество();
	Если Итог = 0 Тогда Возврат 0; КонецЕсли;

	ТаблицаПриемник.Очистить();
	БыстраяЗаливкаКолонками(Буфер, ТаблицаПриемник, ПолучитьМаппингПоИменам(Буфер, ТаблицаПриемник), Итог);
	Возврат Итог;
КонецФункции


Функция ЗагрузитьВТаблицуСМаппингом(ТаблицаИсточник, ТаблицаПриемник, СоответствиеКолонок, Знач Очищать = Ложь) Экспорт
	Если ТаблицаИсточник = Неопределено Или ТаблицаПриемник = Неопределено Тогда
		ВызватьИсключение "Параметры ТаблицаИсточник и ТаблицаПриемник должны быть заполнены";
	КонецЕсли;
	Если СоответствиеКолонок = Неопределено Тогда
		ВызватьИсключение "Параметр СоответствиеКолонок должен быть заполнен";
	КонецЕсли;

	КоличествоСтрок = ТаблицаИсточник.Количество();
	Если КоличествоСтрок = 0 Тогда
		Если Очищать Тогда ТаблицаПриемник.Очистить(); КонецЕсли;
		Возврат 0;
	КонецЕсли;

	Если Очищать Тогда ТаблицаПриемник.Очистить(); КонецЕсли;

	МаппингКолонок = ПодготовитьМаппингКолонок(ТаблицаИсточник, ТаблицаПриемник, СоответствиеКолонок);
	Если МаппингКолонок.Количество() = 0 Тогда Возврат 0; КонецЕсли;

	Старых = ТаблицаПриемник.Количество();
	Если Старых = 0 Тогда
		БыстраяЗаливкаКолонками(ТаблицаИсточник, ТаблицаПриемник, МаппингКолонок, КоличествоСтрок);
		Возврат КоличествоСтрок;
	КонецЕсли;

	Если Старых <= КоличествоСтрок Тогда
		// Стратегия A для заданного маппинга
		СнимокСтарых = СнимокСтрокПоКолонкам(ТаблицаПриемник, Ключи(МаппингКолонок));

		ТаблицаПриемник.Очистить();
		БыстраяЗаливкаКолонками(ТаблицаИсточник, ТаблицаПриемник, МаппингКолонок, КоличествоСтрок);

		Для Каждого Стр Из СнимокСтарых Цикл
			Новая = ТаблицаПриемник.Добавить();
			Для Каждого П Из Стр Цикл
				Новая[П.Ключ] = П.Значение;
			КонецЦикла;
		КонецЦикла;

		Возврат КоличествоСтрок;

	Иначе
		// Стратегия B для заданного маппинга
		ИтогВсего = Старых + КоличествоСтрок;

		СтарыеКолонки = Новый Соответствие;
		Для Каждого Пара Из МаппингКолонок Цикл
			ИмяВПриемнике = Пара.Ключ;
			СтарыеКолонки.Вставить(ИмяВПриемнике, ТаблицаПриемник.ВыгрузитьКолонку(ИмяВПриемнике));
		КонецЦикла;

		Дополнительно = ИтогВсего - Старых;
		Если Дополнительно > 0 Тогда
			Для i = 1 По Дополнительно Цикл
				ТаблицаПриемник.Добавить();
			КонецЦикла;
		КонецЕсли;

		Для Каждого Пара Из МаппингКолонок Цикл
			ИмяВПриемнике = Пара.Ключ;
			ИмяВИсточнике = Пара.Значение;

			МассивСтарых = СтарыеКолонки[ИмяВПриемнике];
			МассивНовых  = ТаблицаИсточник.ВыгрузитьКолонку(ИмяВИсточнике);

			ВсеЗначения = Новый Массив(ИтогВсего);
			Для i = 0 По Старых - 1 Цикл
				ВсеЗначения[i] = МассивСтарых[i];
			КонецЦикла;
			Для j = 0 По КоличествоСтрок - 1 Цикл
				ВсеЗначения[Старых + j] = МассивНовых[j];
			КонецЦикла;

			ТаблицаПриемник.ЗагрузитьКолонку(ВсеЗначения, ИмяВПриемнике);
		КонецЦикла;

		Возврат КоличествоСтрок;
	КонецЕсли;
КонецФункции


Функция ЗагрузитьВТаблицуПолный(ТаблицаИсточник, ТаблицаПриемник, СоответствиеКолонок = Неопределено, Отбор = Неопределено, Знач Очищать = Ложь) Экспорт
	Если ТаблицаИсточник = Неопределено Или ТаблицаПриемник = Неопределено Тогда
		ВызватьИсключение "Параметры ТаблицаИсточник и ТаблицаПриемник должны быть заполнены";
	КонецЕсли;

	КоличествоСтрок = ТаблицаИсточник.Количество();
	Если КоличествоСтрок = 0 Тогда
		Если Очищать Тогда ТаблицаПриемник.Очистить(); КонецЕсли;
		Возврат 0;
	КонецЕсли;

	Если Очищать Тогда ТаблицаПриемник.Очистить(); КонецЕсли;

	Если СоответствиеКолонок <> Неопределено Тогда
		МаппингКолонок = ПодготовитьМаппингКолонок(ТаблицаИсточник, ТаблицаПриемник, СоответствиеКолонок);
	Иначе
		МаппингКолонок = ПолучитьМаппингПоИменам(ТаблицаИсточник, ТаблицаПриемник);
	КонецЕсли;

	Если МаппингКолонок.Количество() = 0 Тогда Возврат 0; КонецЕсли;

	Если Отбор = Неопределено Тогда
		Возврат ЗагрузитьВТаблицуСМаппингом(ТаблицаИсточник, ТаблицаПриемник, МаппингКолонок, Ложь);
	КонецЕсли;

	// С отбором → буфер → быстрая заливка
	Буфер = Новый ТаблицаЗначений;
	Для Каждого К Из ТаблицаПриемник.Колонки Цикл
		Буфер.Колонки.Добавить(К.Имя, К.ТипЗначения, К.Заголовок, К.Ширина);
	КонецЦикла;

	Для Каждого СтрИст Из ТаблицаИсточник Цикл
		Если ПроверитьСтрокуПоОтбору(СтрИст, Отбор) Тогда
			Новая = Буфер.Добавить();
			Для Каждого П Из МаппингКолонок Цикл
				Новая[П.Ключ] = СтрИст[П.Значение];
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;

	Итог = Буфер.Количество();
	Если Итог = 0 Тогда Возврат 0; КонецЕсли;

	ТаблицаПриемник.Очистить();
	БыстраяЗаливкаКолонками(Буфер, ТаблицаПриемник, ПолучитьМаппингПоИменам(Буфер, ТаблицаПриемник), Итог);
	Возврат Итог;
КонецФункции


///////////////////////////////////////////////////////////////////////////////
// ВСПОМОГАТЕЛЬНЫЕ
///////////////////////////////////////////////////////////////////////////////

Процедура БыстраяЗаливкаКолонками(ТаблицаИсточник, ТаблицаПриемник, Маппинг, КоличествоСтрок)
	// 1) пробуем растянуть таблицу первой колонкой (на некоторых сборках это работает)
	ИмяПервВПриемнике  = Неопределено;
	ИмяПервВИсточнике  = Неопределено;

	Для Каждого П Из Маппинг Цикл
		ИмяПервВПриемнике = П.Ключ;
		ИмяПервВИсточнике = П.Значение;
		Прервать;
	КонецЦикла;

	Если ИмяПервВПриемнике <> Неопределено Тогда
		МассивПервой = ТаблицаИсточник.ВыгрузитьКолонку(ИмяПервВИсточнике);
		ТаблицаПриемник.ЗагрузитьКолонку(МассивПервой, ИмяПервВПриемнике);
	КонецЕсли;

	// 2) если строки не создались — создаём их вручную и повторяем первую колонку
	Если ТаблицаПриемник.Количество() = 0 Тогда
		Для i = 1 По КоличествоСтрок Цикл
			ТаблицаПриемник.Добавить();
		КонецЦикла;
		Если ИмяПервВПриемнике <> Неопределено Тогда
			ТаблицаПриемник.ЗагрузитьКолонку(МассивПервой, ИмяПервВПриемнике);
		КонецЕсли;
	КонецЕсли;

	// 3) оставшиеся колонки
	Для Каждого П Из Маппинг Цикл
		Если П.Ключ = ИмяПервВПриемнике Тогда Продолжить; КонецЕсли;
		ТаблицаПриемник.ЗагрузитьКолонку(ТаблицаИсточник.ВыгрузитьКолонку(П.Значение), П.Ключ);
	КонецЦикла;
КонецПроцедуры


// Снимок существующих строк по указанным именам колонок: массив структур {ИмяКолонки: Значение}
Функция СнимокСтрокПоКолонкам(Таблица, ИменаКолонок)
	Результат = Новый Массив(Таблица.Количество());
	Индекс = 0;
	Для Каждого Стр Из Таблица Цикл
		С = Новый Структура;
		Для Каждого Имя Из ИменаКолонок Цикл
			С.Вставить(Имя, Стр[Имя]);
		КонецЦикла;
		Результат[Индекс] = С;
		Индекс = Индекс + 1;
	КонецЦикла;
	Возврат Результат;
КонецФункции


// Маппинг по совпадению имён: ключ = имя в приёмнике, значение = имя в источнике.
Функция ПолучитьМаппингПоИменам(ТаблицаИсточник, ТаблицаПриемник)
	Маппинг = Новый Соответствие;
	Для Каждого КолонкаПриемника Из ТаблицаПриемник.Колонки Цикл
		Если ТаблицаИсточник.Колонки.Найти(КолонкаПриемника.Имя) <> Неопределено Тогда
			Маппинг.Вставить(КолонкаПриемника.Имя, КолонкаПриемника.Имя);
		КонецЕсли;
	КонецЦикла;
	Возврат Маппинг;
КонецФункции


// Общие колонки (имена приёмника).
Функция ПолучитьОбщиеКолонки(ТаблицаИсточник, ТаблицаПриемник)
	КолонкиДляЗагрузки = Новый Массив;
	Для Каждого КолонкаПриемника Из ТаблицаПриемник.Колонки Цикл
		Если ТаблицаИсточник.Колонки.Найти(КолонкаПриемника.Имя) <> Неопределено Тогда
			КолонкиДляЗагрузки.Добавить(КолонкаПриемника.Имя);
		КонецЕсли;
	КонецЦикла;
	Возврат КолонкиДляЗагрузки;
КонецФункции


// Отбор: Структура (И) или Массив структур (ИЛИ).
Функция ПроверитьСтрокуПоОтбору(Строка, Отбор)
	Если ТипЗнч(Отбор) = Тип("Структура") Тогда
		Для Каждого У Из Отбор Цикл
			Если Строка[У.Ключ] <> У.Значение Тогда Возврат Ложь; КонецЕсли;
		КонецЦикла;
		Возврат Истина;
	ИначеЕсли ТипЗнч(Отбор) = Тип("Массив") Тогда
		Для Каждого Вариант Из Отбор Цикл
			Если ПроверитьСтрокуПоОтбору(Строка, Вариант) Тогда Возврат Истина; КонецЕсли;
		КонецЦикла;
		Возврат Ложь;
	КонецЕсли;
	Возврат Истина;
КонецФункции


// Подготовка маппинга колонок: ключ = имя в приёмнике, значение = имя в источнике.
Функция ПодготовитьМаппингКолонок(ТаблицаИсточник, ТаблицаПриемник, СоответствиеКолонок)
	МаппингКолонок = Новый Соответствие;

	Если ТипЗнч(СоответствиеКолонок) = Тип("Структура") Тогда
		Источник = Новый Соответствие;
		Для Каждого П Из СоответствиеКолонок Цикл
			Источник.Вставить(П.Ключ, П.Значение);
		КонецЦикла;
	Иначе
		Источник = СоответствиеКолонок;
	КонецЕсли;

	Для Каждого Э Из Источник Цикл
		Если ТаблицаПриемник.Колонки.Найти(Э.Ключ) <> Неопределено 
			И ТаблицаИсточник.Колонки.Найти(Э.Значение) <> Неопределено Тогда
			МаппингКолонок.Вставить(Э.Ключ, Э.Значение);
		КонецЕсли;
	КонецЦикла;

	Возврат МаппингКолонок;
КонецФункции

#КонецЕсли // Сервер

#КонецОбласти

// =================================================================
// ДОПОЛНИТЕЛЬНЫЕ ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ
// =================================================================

#Region М1сAIОбщие_AdvancedExamples
/// <summary>
/// Расширенные примеры использования трансформации и создания объектов.
/// </summary>
Процедура AdvancedExamples() Экспорт
	
	// === Пример 1: Миграция данных между конфигурациями ===
	
	// Исходная структура из старой конфигурации
	СтараяСтруктура = Новый Структура;
	СтараяСтруктура.Вставить("Подразделение", "Отдел продаж");
	СтараяСтруктура.Вставить("Контрагент", "ООО Рога и копыта");
	СтараяСтруктура.Вставить("СуммаДокумента", 15000);
	СтараяСтруктура.Вставить("УстаревшееПоле", "Удалить это");
	
	// Карта трансформации для новой конфигурации
	КартаМиграции = Новый Структура;
	КартаМиграции.Вставить("Подразделение", "ПодразделениеОрганизации");
	КартаМиграции.Вставить("Контрагент", "КлиентПоставщик");
	КартаМиграции.Вставить("УстаревшееПоле", ""); // Исключаем поле
	
	// Трансформируем
	НоваяСтруктура = М1сAIОбщие.TransformStruct(СтараяСтруктура, КартаМиграции);
	// Результат: ПодразделениеОрганизации, КлиентПоставщик, СуммаДокумента (УстаревшееПоле исключено)
	
	// === Пример 2: Клонирование объекта с изменениями ===
	
	//ИсходныйДокумент = Документы.РеализацияТоваровУслуг.НайтиПоНомеру("001");
	//СтруктураДокумента = М1сAIОбщие.ToStruct(ИсходныйДокумент);
	
	// Быстро очищаем от служебных полей и подготавливаем для нового
	//СтруктураДляНового = М1сAIОбщие.CleanStructForNew(СтруктураДокумента, "Документ.РеализацияТоваровУслуг");
	//СтруктураДляНового.Вставить("Дата", М1сAIОбщие.Now());
	
	// Создаем новый документ
	//НовыйДокумент = М1сAIОбщие.FromStruct(СтруктураДляНового);
	//НовыйДокумент.Записать();
	
	// === Пример 3: Удаление конкретных полей ===
	
	СтруктураПример = Новый Структура("Наименование,Код,Ссылка,ВерсияДанных,Статус", "Тест", "001", "СсылкаТест", 5, "Активный");
	
	// Удаляем только служебные поля
	БезСлужебных = М1сAIОбщие.RemoveKeys(СтруктураПример, "Ссылка,ВерсияДанных");
	М1сAIСтроки.Print("Без служебных: " + СтрСоединить(М1сAIОбщие.Ключи(БезСлужебных), ", "));
	
	// Удаляем все стандартные системные поля
	БезСистемных = М1сAIОбщие.RemoveKeys(СтруктураПример, М1сAIОбщие.StandardSystemKeys());
	М1сAIСтроки.Print("Без системных: " + СтрСоединить(М1сAIОбщие.Ключи(БезСистемных), ", "));
	
	// === Пример 4: Быстрая подготовка для создания нового объекта ===
	
	СтруктураОригинала = Новый Структура;
	СтруктураОригинала.Вставить("Наименование", "Исходный товар");
	СтруктураОригинала.Вставить("Артикул", "АРТ-001");
	СтруктураОригинала.Вставить("Код", "001");
	СтруктураОригинала.Вставить("Ссылка", "СсылкаНаИсходный");
	СтруктураОригинала.Вставить("ВерсияДанных", 10);
	
	// Одной командой очищаем и подготавливаем
	ГотоваяДляСоздания = М1сAIОбщие.CleanStructForNew(СтруктураОригинала, "Справочник.НоменклатураНовая");
	М1сAIСтроки.Print("Готовая структура: " + СтрСоединить(М1сAIОбщие.Ключи(ГотоваяДляСоздания), ", "));
	
	М1сAIСтроки.Print("Примеры трансформации и создания объектов выполнены");
	
КонецПроцедуры
#EndRegion

// =================================================================
// М1сAIОбщие — CORE: универсальные умолчания и ленивые eval-паттерны
// =================================================================

#Region М1сAIОбщие_OrElse
/// <doc>
///   <summary>Возвращает значение, если оно непустое; иначе — умолчание.</summary>
///   <param i="1" name="Значение"  type="Variant">Исходное значение.</param>
///   <param i="2" name="Умолчание" type="Variant">Значение по умолчанию.</param>
///   <returns>Variant — непустое значение или умолчание.</returns>
///   <complexity cc="1"/>
///   <example>
///     Имя = М1сAIОбщие.OrElse(Пользователь.Имя, "Аноним");
///   </example>
/// </doc>
Функция OrElse(Значение, Умолчание) Экспорт
	Если NotEmpty(Значение) Тогда Возврат Значение; КонецЕсли;
	Возврат Умолчание;
КонецФункции
#EndRegion

#Region М1сAIОбщие_OrElseThrow
/// <doc>
///   <summary>Возвращает значение, иначе генерирует исключение (обязательный параметр).</summary>
///   <param i="1" name="Значение"           type="Variant">Исходное значение.</param>
///   <param i="2" name="СообщениеОбОшибке"  type="String"  default="Обязательный параметр не задан">Текст ошибки.</param>
///   <returns>Variant — непустое значение.</returns>
///   <complexity cc="1"/>
///   <example>
///     Токен = М1сAIОбщие.OrElseThrow(Параметры.Токен, "Не задан токен интеграции");
///   </example>
/// </doc>
Функция OrElseThrow(Значение, СообщениеОбОшибке = "Обязательный параметр не задан") Экспорт
	Если NotEmpty(Значение) Тогда Возврат Значение; КонецЕсли;
	ВызватьИсключение СообщениеОбОшибке;
КонецФункции
#EndRegion

#Region М1сAIОбщие_OrElseGetEval
/// <doc>
///   <summary>Ленивое умолчание: если значение пусто — вычисляет выражение строкой и возвращает его (без записи обратно).</summary>
///   <param i="1" name="Значение"          type="Variant">Исходное значение.</param>
///   <param i="2" name="ВыражениеСтрокой"  type="String">BSL-выражение, возвращающее значение. Выполняется ТОЛЬКО при пустоте.</param>
///   <returns>Variant — исходное или вычисленное значение.</returns>
///   <complexity cc="2"/>
///   <example>
///     // Явно указывайте модуль/контекст в выражении
///     URL = М1сAIОбщие.OrElseGetEval(Конф.URLБД, "Конфигурация.LoadURL()");
///   </example>
/// </doc>
Функция OrElseGetEval(Значение, ВыражениеСтрокой) Экспорт
	Если NotEmpty(Значение) Тогда Возврат Значение; КонецЕсли;
	Возврат Вычислить(ВыражениеСтрокой);
КонецФункции
#EndRegion

#Region М1сAIОбщие_OrElseSetEval
/// <doc>
///   <summary>Ленивый кэш через выражение: если переменная пуста — вычисляет строковое выражение, присваивает и возвращает.</summary>
///   <param i="1" name="Переменная"        type="Variant">Переменная для заполнения (без «Знач», чтобы присвоение вернулось вызывающему).</param>
///   <param i="2" name="ВыражениеСтрокой"  type="String">Полное BSL-выражение (рекомендуется с именем модуля), выполняется ТОЛЬКО при пустоте.</param>
///   <returns>Variant — итоговое значение переменной.</returns>
///   <complexity cc="3"/>
///   <example>
///     Перем Логгер;
///     // Хорошо: явно вызываем фабрику из модуля
///     Логгер = М1сAIОбщие.OrElseSetEval(Логгер, "М1сAIЛогирование.Create(""OrderController"")");
///
///     Перем Конфиг;
///     Конфиг = М1сAIОбщие.OrElseSetEval(Конфиг, "Конфигурация.LoadFromFile()");
///   </example>
/// </doc>
Функция OrElseSetEval(Переменная, ВыражениеСтрокой) Экспорт
	Если NotEmpty(Переменная) Тогда Возврат Переменная; КонецЕсли;
	Лок = Вычислить(ВыражениеСтрокой);
	Переменная = Лок;
	Возврат Лок;
КонецФункции
#EndRegion

#Region М1сAIОбщие_DefaultByType
/// <doc>
///   <summary>Возвращает значение или умолчание с попыткой приведения к типу ("Строка","Число","Дата").</summary>
///   <param i="1" name="Значение"    type="Variant">Исходное значение.</param>
///   <param i="2" name="ТипСтрокой"  type="String">Целевой тип ("Строка"|"Число"|"Дата").</param>
///   <param i="3" name="Умолчание"   type="Variant">Возвращается при пустоте/ошибке приведения.</param>
///   <returns>Variant — приведенное значение или умолчание.</returns>
///   <complexity cc="3"/>
///   <example>
///     Текст  = М1сAIОбщие.DefaultByType(Ввод, "Строка", "");
///     Кол-во = М1сAIОбщие.DefaultByType(Ввод, "Число", 0);
///     ДатаП  = М1сAIОбщие.DefaultByType(Ввод, "Дата",  '00010101');
///   </example>
/// </doc>
Функция DefaultByType(Значение, ТипСтрокой, Умолчание) Экспорт
	Если Empty(Значение) Тогда Возврат Умолчание; КонецЕсли;
	Попытка
		Если ТипСтрокой = "Строка" Тогда Возврат Строка(Значение); КонецЕсли;
		Если ТипСтрокой = "Число"  Тогда Возврат Число(Значение);  КонецЕсли;
		Если ТипСтрокой = "Дата"   Тогда Возврат Дата(Значение);   КонецЕсли;
		Возврат Значение;
	Исключение
		Возврат Умолчание;
	КонецПопытки;
КонецФункции
#EndRegion

// =================================================================
// Примеры использования (закомментированы — раскомментируйте для прогона)
// =================================================================

#Region examples_М1сAIОбщие_CoreLazy
// Процедура Examples_CoreLazy() Экспорт
// 	// 1) OrElse — простая подстановка умолчания
// 	Имя = М1сAIОбщие.OrElse(Пользователь.Имя, "Аноним");
// 	// М1сAIСтроки.Print("Имя: " + Имя);
//
// 	// 2) OrElseThrow — обязательный параметр
// 	// Токен = М1сAIОбщие.OrElseThrow(Параметры.Токен, "Не задан токен интеграции");
// 	// М1сAIСтроки.Print("Токен: " + Сред(Токен, 1, 4) + "..."); // если не бросило исключение
//
// 	// 3) OrElseGetEval vs OrElseSetEval — разница в записи
// 	Перем Calls; Calls = 0;
// 	// Локальная «дорогая» функция для демонстрации
// 	// Функция _Expensive() Экспорт
// 	// 	Calls = Calls + 1; Пауза(0.1); Возврат "VAL";
// 	// КонецФункции
//
// 	// 3.1) GetEval — не меняет исходную переменную, будет вызываться каждый раз
// 	Перем V; // Неопределено
// 	_ = М1сAIОбщие.OrElseGetEval(V, "_Expensive()");
// 	_ = М1сAIОбщие.OrElseGetEval(V, "_Expensive()");
// 	// М1сAIСтроки.Print("GetEval calls: " + Строка(Calls)); // ожидаем 2
//
// 	// 3.2) SetEval — сохранит значение и больше не вызовет _Expensive()
// 	Calls = 0;
// 	Перем C; // Неопределено
// 	_ = М1сAIОбщие.OrElseSetEval(C, "_Expensive()");
// 	_ = М1сAIОбщие.OrElseSetEval(C, "_Expensive()");
// 	// М1сAIСтроки.Print("SetEval calls: " + Строка(Calls)); // ожидаем 1
//
// 	// 4) DefaultByType — безопасное приведение с умолчанием
// 	ВводЧисло = "123,45";
// 	Сумма = М1сAIОбщие.DefaultByType(ВводЧисло, "Число", 0);
// 	// М1сAIСтроки.Print("Сумма: " + Формат(Сумма, "ЧГ=15.2"));
//
// 	// 5) Рекомендация по eval: всегда указывайте модуль в выражении
// 	// Перем Логгер;
// 	// Логгер = М1сAIОбщие.OrElseSetEval(Логгер, "М1сAIЛогирование.Create(""OrderController"")");
// КонецПроцедуры
#EndRegion
